/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

/***************************************
 * Copyright 2009 The Closure Library Authors. All Rights Reserved. (Apache License, Version 2.0)
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of SITools2.
 *
 * SITools2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SITools2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 * Copyright (c) 2013, Michael Bostock
 * All rights reserved.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/***************************************
 * Copyright 2011, 2012 Globe contributors.
 *
 * This file is part of Globe.
 *
 * Globe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * Globe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Globe. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

!function() {
    function t(t) {
        if (Math.abs(t) == Math.PI / 2) return t;
        var e, r = .001, i = t;
        do {
            var n = 2 * i;
            i = e, i || (i = t), e = n / 2 - (n + Math.sin(n) - Math.PI * Math.sin(t)) / (2 + 2 * Math.cos(n));
        } while (Math.abs(e - i) >= r);
        return e;
    }
    var e = {};
    e.lerp = function(t, e, r) {
        return e + (r - e) * t;
    }, e.coserp = function(t, e, r) {
        var i = (1 - Math.cos(t * Math.PI)) / 2;
        return e + (r - e) * i;
    }, e.cubicInterpolation = function(t, e, r, i, n) {
        var o = t * t, a = o * t, h = 2 * e[0] - 2 * i[0] + r[0] + n[0], l = 2 * e[1] - 2 * i[1] + r[1] + n[1], u = 2 * e[2] - 2 * i[2] + r[2] + n[2], c = -3 * e[0] + 3 * i[0] - 2 * r[0] - n[0], d = -3 * e[1] + 3 * i[1] - 2 * r[1] - n[1], f = -3 * e[2] + 3 * i[2] - 2 * r[2] - n[2], p = s.create();
        return p[0] = h * a + c * o + r[0] * t + e[0], p[1] = l * a + d * o + r[1] * t + e[1], 
        p[2] = u * a + f * o + r[2] * t + e[2], p;
    }, e.cubicInterpolationDerivative = function(t, e, r, i, n) {
        var o = t * t, a = 6 * e[0] - 6 * i[0] + 3 * r[0] + 3 * n[0], h = 6 * e[1] - 6 * i[1] + 3 * r[1] + 3 * n[1], l = 6 * e[2] - 6 * i[2] + 3 * r[2] + 3 * n[2], u = -6 * e[0] + 6 * i[0] - 4 * r[0] - 2 * n[0], c = -6 * e[1] + 6 * i[1] - 4 * r[1] - 2 * n[1], d = -6 * e[2] + 6 * i[2] - 4 * r[2] - 2 * n[2], f = s.create();
        return f[0] = a * o + u * t + r[0], f[1] = h * o + c * t + r[1], f[2] = l * o + d * t + r[2], 
        f;
    }, e.map01 = function(t, e, r) {
        return e != r ? (t - e) / (r - e) : 0;
    }, e.mapLinear = function(t, r, i, n, o) {
        return e.lerp(e.map01(t, r, i), n, o);
    }, e.easeInQuad = function(t) {
        return t * t;
    }, e.easeOutQuad = function(t) {
        var e = t - 1;
        return 1 - e * e;
    }, e.easeInOutQuad = function(t) {
        var e = t;
        return e < .5 ? (e += e, e = .5 * (e * e)) : (e = e + e - 2, e = .5 * (1 - e * e), 
        e = .5 + e), e;
    }, e.easeOutInQuad = function(t) {
        var e = t;
        return e < .5 ? (e = e + e - 1, e = .5 * (1 - e * e)) : (e = e + e - 1, e = .5 * (e * e), 
        e = .5 + e), e;
    }, e.toRadian = function(t) {
        return t * Math.PI / 180;
    }, e.toDegree = function(t) {
        return 180 * t / Math.PI;
    }, e.lineIntersection = function(t, e, r, i, n, o, s, a) {
        var h = (a - o) * (r - t) - (s - n) * (i - e);
        if (0 == h) return [ -1, -1 ];
        var l = (s - n) * (e - o) - (a - o) * (t - n), u = (r - t) * (e - o) - (i - e) * (t - n);
        return l /= h, u /= h, [ l, u ];
    }, e.roundNumber = function(t, e) {
        var r = Math.round(t * Math.pow(10, e)) / Math.pow(10, e);
        return r;
    };
    var r = function(t) {
        this.radius = t && t.hasOwnProperty("radius") ? t.radius : 1, this.realEarthRadius = t && t.hasOwnProperty("realEarthRadius") ? t.realEarthRadius : 6356752.3142, 
        this.heightScale = 1 / this.realEarthRadius;
    };
    r.prototype.fromGeoTo3D = function(t, r) {
        r || (r = Array(3));
        var i = e.toRadian(t[0]), n = e.toRadian(t[1]), o = Math.cos(n), s = t.length > 2 ? this.heightScale * t[2] : 0, a = this.radius + s;
        return r[0] = a * Math.cos(i) * o, r[1] = a * Math.sin(i) * o, r[2] = a * Math.sin(n), 
        r;
    }, r.prototype.from3DToGeo = function(t, r) {
        r || (r = Array(3));
        var i = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), n = Math.atan2(t[1] / i, t[0] / i), o = Math.asin(t[2] / i);
        return r[0] = e.toDegree(n), r[1] = e.toDegree(o), r[2] = this.realEarthRadius * (i - this.radius), 
        r;
    }, r.prototype.getLocalTransform = function(t, e) {
        e || (e = h.create());
        var r = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, n = [ Math.cos(r) * Math.cos(i), Math.sin(r) * Math.cos(i), Math.sin(i) ], o = [ -Math.sin(r), Math.cos(r), 0 ], a = s.create();
        return s.cross(n, o, a), e[0] = o[0], e[1] = o[1], e[2] = o[2], e[3] = 0, e[4] = a[0], 
        e[5] = a[1], e[6] = a[2], e[7] = 0, e[8] = n[0], e[9] = n[1], e[10] = n[2], e[11] = 0, 
        e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
    }, r.prototype.getLHVTransform = function(t, e) {
        e || (e = h.create());
        var r = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, n = [ Math.cos(r) * Math.cos(i), Math.sin(r) * Math.cos(i), Math.sin(i) ], o = [ -Math.sin(r), Math.cos(r), 0 ], a = s.create();
        s.cross(n, o, a);
        var l = this.fromGeoTo3D(t);
        return e[0] = o[0], e[1] = o[1], e[2] = o[2], e[3] = 0, e[4] = a[0], e[5] = a[1], 
        e[6] = a[2], e[7] = 0, e[8] = n[0], e[9] = n[1], e[10] = n[2], e[11] = 0, e[12] = l[0], 
        e[13] = l[1], e[14] = l[2], e[15] = 1, e;
    }, r.prototype.getSideVector = function(t, e) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }, r.prototype.getFrontVector = function(t, e) {
        return e[0] = t[4], e[1] = t[5], e[2] = t[6], e;
    }, r.prototype.getUpVector = function(t, e) {
        return e[0] = t[8], e[1] = t[9], e[2] = t[10], e;
    };
    var n = 1e-6, o = Array, s = {};
    s.create = function(t) {
        var e = new o(3);
        return t ? (e[0] = t[0], e[1] = t[1], e[2] = t[2]) : e[0] = e[1] = e[2] = 0, e;
    }, s.createFrom = function(t, e, r) {
        var i = new o(3);
        return i[0] = t, i[1] = e, i[2] = r, i;
    }, s.set = function(t, e) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }, s.equal = function(t, e) {
        return t === e || Math.abs(t[0] - e[0]) < n && Math.abs(t[1] - e[1]) < n && Math.abs(t[2] - e[2]) < n;
    }, s.add = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] + e[0], r[1] = t[1] + e[1], r[2] = t[2] + e[2], 
        r) : (t[0] += e[0], t[1] += e[1], t[2] += e[2], t);
    }, s.subtract = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] - e[0], r[1] = t[1] - e[1], r[2] = t[2] - e[2], 
        r) : (t[0] -= e[0], t[1] -= e[1], t[2] -= e[2], t);
    }, s.multiply = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] * e[0], r[1] = t[1] * e[1], r[2] = t[2] * e[2], 
        r) : (t[0] *= e[0], t[1] *= e[1], t[2] *= e[2], t);
    }, s.negate = function(t, e) {
        return e || (e = t), e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;
    }, s.scale = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e, r) : (t[0] *= e, 
        t[1] *= e, t[2] *= e, t);
    }, s.normalize = function(t, e) {
        e || (e = t);
        var r = t[0], i = t[1], n = t[2], o = Math.sqrt(r * r + i * i + n * n);
        return o ? 1 === o ? (e[0] = r, e[1] = i, e[2] = n, e) : (o = 1 / o, e[0] = r * o, 
        e[1] = i * o, e[2] = n * o, e) : (e[0] = 0, e[1] = 0, e[2] = 0, e);
    }, s.cross = function(t, e, r) {
        r || (r = t);
        var i = t[0], n = t[1], o = t[2], s = e[0], a = e[1], h = e[2];
        return r[0] = n * h - o * a, r[1] = o * s - i * h, r[2] = i * a - n * s, r;
    }, s.length = function(t) {
        var e = t[0], r = t[1], i = t[2];
        return Math.sqrt(e * e + r * r + i * i);
    }, s.squaredLength = function(t) {
        var e = t[0], r = t[1], i = t[2];
        return e * e + r * r + i * i;
    }, s.dot = function(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }, s.lerp = function(t, e, r, i) {
        return i || (i = t), i[0] = t[0] + r * (e[0] - t[0]), i[1] = t[1] + r * (e[1] - t[1]), 
        i[2] = t[2] + r * (e[2] - t[2]), i;
    }, s.dist = function(t, e) {
        var r = e[0] - t[0], i = e[1] - t[1], n = e[2] - t[2];
        return Math.sqrt(r * r + i * i + n * n);
    }, s.angle = function(t, e) {
        return Math.atan2(s.length(s.cross(t, e)), s.dot(t, e));
    }, s.str = function(t) {
        return "[" + t[0] + ", " + t[1] + ", " + t[2] + "]";
    }, s.createZPhi = function(t, e) {
        var r = Math.sqrt((1 - t) * (1 + t)), i = r * Math.cos(e), n = r * Math.sin(e);
        return s.createFrom(i, n, t);
    }, s.createPhiTheta = function(t, e) {
        var r = Math.sin(e), i = r * Math.cos(t), n = r * Math.sin(t), o = r * Math.cos(e);
        return s.createFrom(i, n, o);
    }, s.add2 = function(t, e) {
        var r = t[0], i = t[1], n = t[2], o = e[0], s = e[1], a = e[2];
        return [ r + o, i + s, n + a ];
    }, s.subtract2 = function(t, e) {
        var r = t[0], i = t[1], n = t[2], o = e[0], s = e[1], a = e[2];
        return [ r - o, i - s, n - a ];
    }, s.flip = function(t) {
        var e = t[0], r = t[1], i = t[2];
        return [ e = -e, r = -r, i = -i ];
    }, s.scale2 = function(t, e) {
        var r = t.x, i = t.y, n = t.z;
        return {
            x: r * e,
            y: i *= e,
            z: n *= e
        };
    }, s.normalize2 = function(t) {
        var e = t[0], r = t[1], i = t[2], n = 1 / Math.sqrt(e * e + r * r + i * i);
        return [ e *= n, r *= n, i *= n ];
    }, s.cross2 = function(t, e) {
        return {
            x: t[1] * e[2] - e[1] * t[2],
            y: t[2] * e[0] - e[2] * t[0],
            z: t[0] * e[1] - e[0] * t[1]
        };
    }, s.length2 = function(t) {
        var e = t.x, r = t.y, i = t.z;
        return Math.sqrt(e * e + r * r + i * i);
    }, s.dot2 = function(t, e) {
        var r = void 0 != t.x ? t.x : t[0], i = void 0 != t.y ? t.y : t[1], n = void 0 != t.z ? t.z : t[2], o = void 0 != e.x ? e.x : e[0], s = void 0 != e.y ? e.y : e[1], a = void 0 != e.z ? e.z : e[2];
        return r * o + i * s + n * a;
    }, s.angle2 = function(t, e) {
        return Math.atan2(s.length2(s.cross2(t, e)), s.dot2(t, e));
    };
    var a = {};
    a.create = function(t) {
        var e = new o(9);
        return t && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], 
        e[6] = t[6], e[7] = t[7], e[8] = t[8]), e;
    };
    var h = {};
    h.create = function(t) {
        var e = new o(16);
        return t && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], 
        e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], 
        e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e;
    }, h.set = function(t, e) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], 
        e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], 
        e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
    }, h.identity = function(t) {
        return t || (t = h.create()), t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, 
        t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, 
        t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, h.transpose = function(t, e) {
        if (!e || t === e) {
            var r = t[1], i = t[2], n = t[3], o = t[6], s = t[7], a = t[11];
            return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = r, t[6] = t[9], t[7] = t[13], 
            t[8] = i, t[9] = o, t[11] = t[14], t[12] = n, t[13] = s, t[14] = a, t;
        }
        return e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], 
        e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], 
        e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15], e;
    }, h.determinant = function(t) {
        var e = t[0], r = t[1], i = t[2], n = t[3], o = t[4], s = t[5], a = t[6], h = t[7], l = t[8], u = t[9], c = t[10], d = t[11], f = t[12], p = t[13], m = t[14], v = t[15];
        return f * u * a * n - l * p * a * n - f * s * c * n + o * p * c * n + l * s * m * n - o * u * m * n - f * u * i * h + l * p * i * h + f * r * c * h - e * p * c * h - l * r * m * h + e * u * m * h + f * s * i * d - o * p * i * d - f * r * a * d + e * p * a * d + o * r * m * d - e * s * m * d - l * s * i * v + o * u * i * v + l * r * a * v - e * u * a * v - o * r * c * v + e * s * c * v;
    }, h.inverse = function(t, e) {
        e || (e = t);
        var r, i = t[0], n = t[1], o = t[2], s = t[3], a = t[4], h = t[5], l = t[6], u = t[7], c = t[8], d = t[9], f = t[10], p = t[11], m = t[12], v = t[13], g = t[14], y = t[15], x = i * h - n * a, b = i * l - o * a, T = i * u - s * a, _ = n * l - o * h, M = n * u - s * h, R = o * u - s * l, S = c * v - d * m, w = c * g - f * m, P = c * y - p * m, E = d * g - f * v, C = d * y - p * v, I = f * y - p * g, L = x * I - b * C + T * E + _ * P - M * w + R * S;
        return L ? (r = 1 / L, e[0] = (h * I - l * C + u * E) * r, e[1] = (-n * I + o * C - s * E) * r, 
        e[2] = (v * R - g * M + y * _) * r, e[3] = (-d * R + f * M - p * _) * r, e[4] = (-a * I + l * P - u * w) * r, 
        e[5] = (i * I - o * P + s * w) * r, e[6] = (-m * R + g * T - y * b) * r, e[7] = (c * R - f * T + p * b) * r, 
        e[8] = (a * C - h * P + u * S) * r, e[9] = (-i * C + n * P - s * S) * r, e[10] = (m * M - v * T + y * x) * r, 
        e[11] = (-c * M + d * T - p * x) * r, e[12] = (-a * E + h * w - l * S) * r, e[13] = (i * E - n * w + o * S) * r, 
        e[14] = (-m * _ + v * b - g * x) * r, e[15] = (c * _ - d * b + f * x) * r, e) : null;
    }, h.toRotationMat = function(t, e) {
        return e || (e = h.create()), e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], 
        e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], 
        e[11] = t[11], e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
    }, h.toMat3 = function(t, e) {
        return e || (e = a.create()), e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], 
        e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;
    }, h.multiply = function(t, e, r) {
        r || (r = t);
        var i = t[0], n = t[1], o = t[2], s = t[3], a = t[4], h = t[5], l = t[6], u = t[7], c = t[8], d = t[9], f = t[10], p = t[11], m = t[12], v = t[13], g = t[14], y = t[15], x = e[0], b = e[1], T = e[2], _ = e[3];
        return r[0] = x * i + b * a + T * c + _ * m, r[1] = x * n + b * h + T * d + _ * v, 
        r[2] = x * o + b * l + T * f + _ * g, r[3] = x * s + b * u + T * p + _ * y, x = e[4], 
        b = e[5], T = e[6], _ = e[7], r[4] = x * i + b * a + T * c + _ * m, r[5] = x * n + b * h + T * d + _ * v, 
        r[6] = x * o + b * l + T * f + _ * g, r[7] = x * s + b * u + T * p + _ * y, x = e[8], 
        b = e[9], T = e[10], _ = e[11], r[8] = x * i + b * a + T * c + _ * m, r[9] = x * n + b * h + T * d + _ * v, 
        r[10] = x * o + b * l + T * f + _ * g, r[11] = x * s + b * u + T * p + _ * y, x = e[12], 
        b = e[13], T = e[14], _ = e[15], r[12] = x * i + b * a + T * c + _ * m, r[13] = x * n + b * h + T * d + _ * v, 
        r[14] = x * o + b * l + T * f + _ * g, r[15] = x * s + b * u + T * p + _ * y, r;
    }, h.multiplyVec3 = function(t, e, r) {
        r || (r = e);
        var i = e[0], n = e[1], o = e[2];
        return r[0] = t[0] * i + t[4] * n + t[8] * o + t[12], r[1] = t[1] * i + t[5] * n + t[9] * o + t[13], 
        r[2] = t[2] * i + t[6] * n + t[10] * o + t[14], r;
    }, h.multiplyVec4 = function(t, e, r) {
        r || (r = e);
        var i = e[0], n = e[1], o = e[2], s = e[3];
        return r[0] = t[0] * i + t[4] * n + t[8] * o + t[12] * s, r[1] = t[1] * i + t[5] * n + t[9] * o + t[13] * s, 
        r[2] = t[2] * i + t[6] * n + t[10] * o + t[14] * s, r[3] = t[3] * i + t[7] * n + t[11] * o + t[15] * s, 
        r;
    }, h.project = function(t, e, r) {
        r || (r = e), h.multiplyVec4(t, e, r);
        var i = 1 / r[3];
        return r[0] *= i, r[1] *= i, r[2] *= i, r;
    }, h.rotateVec3 = function(t, e, r) {
        r || (r = e);
        var i = e[0], n = e[1], o = e[2];
        return r[0] = t[0] * i + t[4] * n + t[8] * o, r[1] = t[1] * i + t[5] * n + t[9] * o, 
        r[2] = t[2] * i + t[6] * n + t[10] * o, r;
    }, h.translate = function(t, e, r) {
        var i, n, o, s, a, h, l, u, c, d, f, p, m = e[0], v = e[1], g = e[2];
        return r && t !== r ? (i = t[0], n = t[1], o = t[2], s = t[3], a = t[4], h = t[5], 
        l = t[6], u = t[7], c = t[8], d = t[9], f = t[10], p = t[11], r[0] = i, r[1] = n, 
        r[2] = o, r[3] = s, r[4] = a, r[5] = h, r[6] = l, r[7] = u, r[8] = c, r[9] = d, 
        r[10] = f, r[11] = p, r[12] = i * m + a * v + c * g + t[12], r[13] = n * m + h * v + d * g + t[13], 
        r[14] = o * m + l * v + f * g + t[14], r[15] = s * m + u * v + p * g + t[15], r) : (t[12] = t[0] * m + t[4] * v + t[8] * g + t[12], 
        t[13] = t[1] * m + t[5] * v + t[9] * g + t[13], t[14] = t[2] * m + t[6] * v + t[10] * g + t[14], 
        t[15] = t[3] * m + t[7] * v + t[11] * g + t[15], t);
    }, h.scale = function(t, e, r) {
        var i = e[0], n = e[1], o = e[2];
        return r && t !== r ? (r[0] = t[0] * i, r[1] = t[1] * i, r[2] = t[2] * i, r[3] = t[3] * i, 
        r[4] = t[4] * n, r[5] = t[5] * n, r[6] = t[6] * n, r[7] = t[7] * n, r[8] = t[8] * o, 
        r[9] = t[9] * o, r[10] = t[10] * o, r[11] = t[11] * o, r[12] = t[12], r[13] = t[13], 
        r[14] = t[14], r[15] = t[15], r) : (t[0] *= i, t[1] *= i, t[2] *= i, t[3] *= i, 
        t[4] *= n, t[5] *= n, t[6] *= n, t[7] *= n, t[8] *= o, t[9] *= o, t[10] *= o, t[11] *= o, 
        t);
    }, h.rotate = function(t, e, r, i) {
        var n, o, s, a, h, l, u, c, d, f, p, m, v, g, y, x, b, T, _, M, R, S, w, P, E = r[0], C = r[1], I = r[2], L = Math.sqrt(E * E + C * C + I * I);
        return L ? (1 !== L && (L = 1 / L, E *= L, C *= L, I *= L), n = Math.sin(e), o = Math.cos(e), 
        s = 1 - o, a = t[0], h = t[1], l = t[2], u = t[3], c = t[4], d = t[5], f = t[6], 
        p = t[7], m = t[8], v = t[9], g = t[10], y = t[11], x = E * E * s + o, b = C * E * s + I * n, 
        T = I * E * s - C * n, _ = E * C * s - I * n, M = C * C * s + o, R = I * C * s + E * n, 
        S = E * I * s + C * n, w = C * I * s - E * n, P = I * I * s + o, i ? t !== i && (i[12] = t[12], 
        i[13] = t[13], i[14] = t[14], i[15] = t[15]) : i = t, i[0] = a * x + c * b + m * T, 
        i[1] = h * x + d * b + v * T, i[2] = l * x + f * b + g * T, i[3] = u * x + p * b + y * T, 
        i[4] = a * _ + c * M + m * R, i[5] = h * _ + d * M + v * R, i[6] = l * _ + f * M + g * R, 
        i[7] = u * _ + p * M + y * R, i[8] = a * S + c * w + m * P, i[9] = h * S + d * w + v * P, 
        i[10] = l * S + f * w + g * P, i[11] = u * S + p * w + y * P, i) : null;
    }, h.rotateX = function(t, e, r) {
        var i = Math.sin(e), n = Math.cos(e), o = t[4], s = t[5], a = t[6], h = t[7], l = t[8], u = t[9], c = t[10], d = t[11];
        return r ? t !== r && (r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[12] = t[12], 
        r[13] = t[13], r[14] = t[14], r[15] = t[15]) : r = t, r[4] = o * n + l * i, r[5] = s * n + u * i, 
        r[6] = a * n + c * i, r[7] = h * n + d * i, r[8] = o * -i + l * n, r[9] = s * -i + u * n, 
        r[10] = a * -i + c * n, r[11] = h * -i + d * n, r;
    }, h.rotateY = function(t, e, r) {
        var i = Math.sin(e), n = Math.cos(e), o = t[0], s = t[1], a = t[2], h = t[3], l = t[8], u = t[9], c = t[10], d = t[11];
        return r ? t !== r && (r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[12] = t[12], 
        r[13] = t[13], r[14] = t[14], r[15] = t[15]) : r = t, r[0] = o * n + l * -i, r[1] = s * n + u * -i, 
        r[2] = a * n + c * -i, r[3] = h * n + d * -i, r[8] = o * i + l * n, r[9] = s * i + u * n, 
        r[10] = a * i + c * n, r[11] = h * i + d * n, r;
    }, h.rotateZ = function(t, e, r) {
        var i = Math.sin(e), n = Math.cos(e), o = t[0], s = t[1], a = t[2], h = t[3], l = t[4], u = t[5], c = t[6], d = t[7];
        return r ? t !== r && (r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], 
        r[13] = t[13], r[14] = t[14], r[15] = t[15]) : r = t, r[0] = o * n + l * i, r[1] = s * n + u * i, 
        r[2] = a * n + c * i, r[3] = h * n + d * i, r[4] = o * -i + l * n, r[5] = s * -i + u * n, 
        r[6] = a * -i + c * n, r[7] = h * -i + d * n, r;
    }, h.frustum = function(t, e, r, i, n, o, s) {
        s || (s = h.create());
        var a = e - t, l = i - r, u = o - n;
        return s[0] = 2 * n / a, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * n / l, 
        s[6] = 0, s[7] = 0, s[8] = (e + t) / a, s[9] = (i + r) / l, s[10] = -(o + n) / u, 
        s[11] = -1, s[12] = 0, s[13] = 0, s[14] = -(o * n * 2) / u, s[15] = 0, s;
    }, h.perspective = function(t, e, r, i, n) {
        var o = r * Math.tan(t * Math.PI / 360), s = o * e;
        return h.frustum(-s, s, -o, o, r, i, n);
    }, h.ortho = function(t, e, r, i, n, o, s) {
        s || (s = h.create());
        var a = e - t, l = i - r, u = o - n;
        return s[0] = 2 / a, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 / l, s[6] = 0, 
        s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -2 / u, s[11] = 0, s[12] = -(t + e) / a, s[13] = -(i + r) / l, 
        s[14] = -(o + n) / u, s[15] = 1, s;
    }, h.lookAt = function(t, e, r, i) {
        i || (i = h.create());
        var n, o, s, a, l, u, c, d, f, p, m = t[0], v = t[1], g = t[2], y = r[0], x = r[1], b = r[2], T = e[0], _ = e[1], M = e[2];
        return m === T && v === _ && g === M ? h.identity(i) : (c = m - T, d = v - _, f = g - M, 
        p = 1 / Math.sqrt(c * c + d * d + f * f), c *= p, d *= p, f *= p, n = x * f - b * d, 
        o = b * c - y * f, s = y * d - x * c, p = Math.sqrt(n * n + o * o + s * s), p ? (p = 1 / p, 
        n *= p, o *= p, s *= p) : (n = 0, o = 0, s = 0), a = d * s - f * o, l = f * n - c * s, 
        u = c * o - d * n, p = Math.sqrt(a * a + l * l + u * u), p ? (p = 1 / p, a *= p, 
        l *= p, u *= p) : (a = 0, l = 0, u = 0), i[0] = n, i[1] = a, i[2] = c, i[3] = 0, 
        i[4] = o, i[5] = l, i[6] = d, i[7] = 0, i[8] = s, i[9] = u, i[10] = f, i[11] = 0, 
        i[12] = -(n * m + o * v + s * g), i[13] = -(a * m + l * v + u * g), i[14] = -(c * m + d * v + f * g), 
        i[15] = 1, i);
    }, h.str = function(t) {
        return "[" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + "]";
    };
    var l = {};
    l.create = function(t) {
        var e = new o(4);
        return t ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]) : e[0] = e[1] = e[2] = e[3] = 0, 
        e;
    }, l.createFrom = function(t, e, r, i) {
        var n = new o(4);
        return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n;
    }, l.set = function(t, e) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
    }, l.equal = function(t, e) {
        return t === e || Math.abs(t[0] - e[0]) < n && Math.abs(t[1] - e[1]) < n && Math.abs(t[2] - e[2]) < n && Math.abs(t[3] - e[3]) < n;
    }, l.identity = function(t) {
        return t || (t = l.create()), t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, l.calculateW = function(t, e) {
        var r = t[0], i = t[1], n = t[2];
        return e && t !== e ? (e[0] = r, e[1] = i, e[2] = n, e[3] = -Math.sqrt(Math.abs(1 - r * r - i * i - n * n)), 
        e) : (t[3] = -Math.sqrt(Math.abs(1 - r * r - i * i - n * n)), t);
    }, l.dot = function(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
    }, l.inverse = function(t, e) {
        var r = t[0], i = t[1], n = t[2], o = t[3], s = r * r + i * i + n * n + o * o, a = s ? 1 / s : 0;
        return e && t !== e ? (e[0] = -t[0] * a, e[1] = -t[1] * a, e[2] = -t[2] * a, e[3] = t[3] * a, 
        e) : (t[0] *= -a, t[1] *= -a, t[2] *= -a, t[3] *= a, t);
    }, l.conjugate = function(t, e) {
        return e && t !== e ? (e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e) : (t[0] *= -1, 
        t[1] *= -1, t[2] *= -1, t);
    }, l.length = function(t) {
        var e = t[0], r = t[1], i = t[2], n = t[3];
        return Math.sqrt(e * e + r * r + i * i + n * n);
    }, l.normalize = function(t, e) {
        e || (e = t);
        var r = t[0], i = t[1], n = t[2], o = t[3], s = Math.sqrt(r * r + i * i + n * n + o * o);
        return 0 === s ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e) : (s = 1 / s, e[0] = r * s, 
        e[1] = i * s, e[2] = n * s, e[3] = o * s, e);
    }, l.add = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] + e[0], r[1] = t[1] + e[1], r[2] = t[2] + e[2], 
        r[3] = t[3] + e[3], r) : (t[0] += e[0], t[1] += e[1], t[2] += e[2], t[3] += e[3], 
        t);
    }, l.multiply = function(t, e, r) {
        r || (r = t);
        var i = t[0], n = t[1], o = t[2], s = t[3], a = e[0], h = e[1], l = e[2], u = e[3];
        return r[0] = i * u + s * a + n * l - o * h, r[1] = n * u + s * h + o * a - i * l, 
        r[2] = o * u + s * l + i * h - n * a, r[3] = s * u - i * a - n * h - o * l, r;
    }, l.multiplyVec3 = function(t, e, r) {
        r || (r = e);
        var i = e[0], n = e[1], o = e[2], s = t[0], a = t[1], h = t[2], l = t[3], u = l * i + a * o - h * n, c = l * n + h * i - s * o, d = l * o + s * n - a * i, f = -s * i - a * n - h * o;
        return r[0] = u * l + f * -s + c * -h - d * -a, r[1] = c * l + f * -a + d * -s - u * -h, 
        r[2] = d * l + f * -h + u * -a - c * -s, r;
    }, l.scale = function(t, e, r) {
        return r && t !== r ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e, r[3] = t[3] * e, 
        r) : (t[0] *= e, t[1] *= e, t[2] *= e, t[3] *= e, t);
    }, l.toMat4 = function(t, e) {
        e || (e = h.create());
        var r = t[0], i = t[1], n = t[2], o = t[3], s = r + r, a = i + i, l = n + n, u = r * s, c = r * a, d = r * l, f = i * a, p = i * l, m = n * l, v = o * s, g = o * a, y = o * l;
        return e[0] = 1 - (f + m), e[1] = c + y, e[2] = d - g, e[3] = 0, e[4] = c - y, e[5] = 1 - (u + m), 
        e[6] = p + v, e[7] = 0, e[8] = d + g, e[9] = p - v, e[10] = 1 - (u + f), e[11] = 0, 
        e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
    }, l.slerp = function(t, e, r, i) {
        i || (i = t);
        var n, o, s, a, h = t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
        return Math.abs(h) >= 1 ? (i !== t && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3]), 
        i) : (n = Math.acos(h), o = Math.sqrt(1 - h * h), Math.abs(o) < .001 ? (i[0] = .5 * t[0] + .5 * e[0], 
        i[1] = .5 * t[1] + .5 * e[1], i[2] = .5 * t[2] + .5 * e[2], i[3] = .5 * t[3] + .5 * e[3], 
        i) : (s = Math.sin((1 - r) * n) / o, a = Math.sin(r * n) / o, i[0] = t[0] * s + e[0] * a, 
        i[1] = t[1] * s + e[1] * a, i[2] = t[2] * s + e[2] * a, i[3] = t[3] * s + e[3] * a, 
        i));
    }, l.fromRotationMatrix = function(t, e) {
        e || (e = l.create());
        var r, i = t[0] + t[4] + t[8];
        if (i > 0) r = Math.sqrt(i + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[7] - t[5]) * r, 
        e[1] = (t[2] - t[6]) * r, e[2] = (t[3] - t[1]) * r; else {
            var n = l.fromRotationMatrix.s_iNext = l.fromRotationMatrix.s_iNext || [ 1, 2, 0 ], o = 0;
            t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);
            var s = n[o], a = n[s];
            r = Math.sqrt(t[3 * o + o] - t[3 * s + s] - t[3 * a + a] + 1), e[o] = .5 * r, r = .5 / r, 
            e[3] = (t[3 * a + s] - t[3 * s + a]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r, 
            e[a] = (t[3 * a + o] + t[3 * o + a]) * r;
        }
        return e;
    }, l.identity = function(t) {
        return t || (t = l.create()), t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, l.fromAngleAxis = function(t, e, r) {
        r || (r = l.create());
        var i = .5 * t, n = Math.sin(i);
        return r[3] = Math.cos(i), r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r;
    }, l.toAngleAxis = function(t, e) {
        e || (e = t);
        var r = t[0] * t[0] + t[1] * t[1] + t[2] * t[2];
        if (r > 0) {
            e[3] = 2 * Math.acos(t[3]);
            var i = 1 / Math.sqrt(r);
            e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i;
        } else e[3] = 0, e[0] = 1, e[1] = 0, e[2] = 0;
        return e;
    }, l.str = function(t) {
        return "[" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + "]";
    }, window.vec3 = s, window.mat4 = h, window.quat4 = l;
    var u = function() {
        this.normal = s.create([ 0, 0, 0 ]), this.d = 0;
    };
    u.prototype.init = function(t, e, r) {
        var i = [], n = [];
        s.subtract(e, t, i), s.subtract(r, t, n), s.cross(i, n, this.normal), s.normalize(this.normal), 
        this.d = -s.dot(t, this.normal);
    }, u.prototype.transform = function(t) {
        var e = [ this.normal[0], this.normal[1], this.normal[2], this.d ];
        h.multiplyVec4(t, e), this.normal[0] = e[0], this.normal[1] = e[1], this.normal[2] = e[2], 
        this.d = e[3];
    }, u.prototype.intersectSphere = function(t, e) {
        var r = s.dot(t, this.normal) + this.d;
        return r > e ? 1 : r < -e ? -1 : 0;
    }, u.prototype.distance = function(t) {
        return t[0] * this.normal[0] + t[1] * this.normal[1] + t[2] * this.normal[2] + this.d;
    }, u.prototype.intersectBoundingBox = function(t) {
        var e = (this.normal[0] >= 0 ? 1 : 0) | (this.normal[1] >= 0 ? 2 : 0) | (this.normal[2] >= 0 ? 4 : 0), r = 7 & ~e;
        return this.distance(t.getCorner(r)) > 0 ? 1 : this.distance(t.getCorner(e)) < 0 ? -1 : 0;
    };
    var c = function() {
        this.planes = [ new u(), new u(), new u(), new u(), new u() ];
    };
    c.prototype.compute = function(t) {
        var e = h.create();
        h.inverse(t, e);
        var r = h.project(e, [ -1, -1, -1, 1 ]), i = h.project(e, [ -1, 1, -1, 1 ]), n = h.project(e, [ 1, 1, -1, 1 ]), o = h.project(e, [ 1, -1, -1, 1 ]);
        this.planes[0].init([ 0, 0, 0 ], r, i), this.planes[1].init([ 0, 0, 0 ], i, n), 
        this.planes[2].init([ 0, 0, 0 ], n, o), this.planes[3].init([ 0, 0, 0 ], o, r), 
        this.planes[4].init(r, i, n);
    }, c.prototype.transform = function(t, e) {
        var r = h.create();
        h.inverse(e, r), this.inverseTransform(t, r);
    }, c.prototype.inverseTransform = function(t, e) {
        for (var r = 0; r < t.planes.length; r++) {
            var i = t.planes[r], n = i.normal[0], o = i.normal[1], s = i.normal[2], a = i.d;
            i = this.planes[r], i.normal[0] = e[0] * n + e[1] * o + e[2] * s + e[3] * a, i.normal[1] = e[4] * n + e[5] * o + e[6] * s + e[7] * a, 
            i.normal[2] = e[8] * n + e[9] * o + e[10] * s + e[11] * a, i.d = e[12] * n + e[13] * o + e[14] * s + e[15] * a;
        }
    }, c.prototype.containsSphere = function(t, e) {
        for (var r = 1, i = 0; i < this.planes.length; i++) {
            var n = this.planes[i].normal, o = t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + this.planes[i].d;
            if (o <= e) {
                if (o < -e) return -1;
                r = 0;
            }
        }
        return r;
    }, c.prototype.containsBoundingBox = function(t) {
        for (var e = 0; e < this.planes.length; e++) {
            var r = this.planes[e], i = r.normal[0] >= 0 ? t.max[0] : t.min[0], n = r.normal[1] >= 0 ? t.max[1] : t.min[1], o = r.normal[2] >= 0 ? t.max[2] : t.min[2], s = i * r.normal[0] + n * r.normal[1] + o * r.normal[2] + r.d;
            if (s < 0) return !1;
        }
        return !0;
    }, c.Plane = u;
    var d = function(t) {
        this.activeAnimations = [], this.shadersPath = t.shadersPath || "../shaders/", this.tileErrorTreshold = t.tileErrorTreshold || 4, 
        this.lighting = t.lighting || !1, this.continuousRendering = t.continuousRendering || !1, 
        this.stats = null, this.isActive = !0;
        var e = null;
        if (!t.canvas) throw "GlobWeb : no canvas in options";
        if (e = "string" == typeof t.canvas ? document.getElementById(t.canvas) : t.canvas, 
        !e instanceof HTMLCanvasElement) throw "GlobWeb : invalid canvas";
        for (var r = [ "webgl", "experimental-webgl", "webkit-3d", "moz-webgl" ], i = null, n = 0; n < r.length && null == i; ++n) try {
            i = e.getContext(r[n], d.contextAttributes);
        } catch (t) {}
        if (null == i) throw "GlobWeb : WebGL context cannot be initialized";
        if (t.backgroundColor) {
            var o = t.backgroundColor;
            i.clearColor(o[0], o[1], o[2], o[3]);
        } else i.clearColor(0, 0, 0, 1);
        i.getExtension("OES_element_index_uint"), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE), 
        i.enable(i.DEPTH_TEST), i.enable(i.CULL_FACE), this.viewMatrix = h.create(), this.modelViewMatrix = h.create(), 
        this.projectionMatrix = h.create(), this.gl = i, this.canvas = e, this.frustum = new c(), 
        this.worldFrustum = new c(), this.localFrustum = new c(), this.eyePosition = s.create(), 
        this.eyeDirection = s.create(), this.minNear = 1e-4, this.minFar = t.minFar || 0, 
        this.near = d.minNear, this.far = 6, this.numActiveAttribArray = 0, this.frameRequested = !1, 
        this.fov = 45, this.renderers = [], window.requestAnimationFrame || (window.requestAnimationFrame = function() {
            return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t, e) {
                window.setTimeout(t, 1e3 / 60);
            };
        }());
        var a = this;
        this.frameCallback = function() {
            a.frame();
        };
    };
    d.contextAttributes = {}, d.prototype.requestFrame = function() {
        this.frameRequested || (window.requestAnimationFrame(this.frameCallback), this.frameRequested = !0);
    }, d.prototype.deactivate = function() {
        this.isActive = !1, this.frameRequested = !1;
    }, d.prototype.activate = function() {
        this.isActive = !0;
    }, d.prototype.frame = function() {
        if (this.isActive) {
            this.frameRequested = !1;
            var t = this.stats, e = this.gl;
            if (t && t.start("globalRenderTime"), this.activeAnimations.length > 0) for (var r = Date.now(), i = 0; i < this.activeAnimations.length; i++) this.activeAnimations[i].update(r);
            if (d.contextAttributes.stencil ? e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT) : e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT), 
            0 == this.canvas.width || 0 == this.canvas.height) return;
            e.viewport(0, 0, this.canvas.width, this.canvas.height), this.updateViewDependentProperties();
            for (var i = 0; i < this.renderers.length; i++) this.renderers[i].render();
            t && t.end("globalRenderTime"), this.continuousRendering ? this.requestFrame() : this.activeAnimations.length > 0 && this.requestFrame();
        }
    }, d.prototype.updateViewDependentProperties = function() {
        var t = h.create();
        h.inverse(this.viewMatrix, t), s.set([ 0, 0, 0 ], this.eyePosition), h.multiplyVec3(t, this.eyePosition), 
        s.set([ 0, 0, -1 ], this.eyeDirection), h.rotateVec3(t, this.eyeDirection), h.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix), 
        this.frustum.compute(this.projectionMatrix), this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix), 
        this.pixelSizeVector = this.computePixelSizeVector();
    }, d.prototype.getXYRelativeToCanvas = function(t) {
        var e = [];
        t.pageX || t.pageY ? (e[0] = t.pageX, e[1] = t.pageY) : (e[0] = t.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, 
        e[1] = t.clientY + document.body.scrollTop + document.documentElement.scrollTop);
        for (var r = this.canvas; r; ) e[0] -= r.offsetLeft, e[1] -= r.offsetTop, r = r.offsetParent;
        return e;
    }, d.prototype.computePixelSizeVector = function(t) {
        var e = this.canvas.width, r = this.canvas.height, i = this.projectionMatrix, n = t || this.viewMatrix, o = i[0] * e * .5, a = i[8] * e * .5 + i[11] * e * .5, h = [ n[0] * o + n[2] * a, n[4] * o + n[6] * a, n[8] * o + n[10] * a ], l = i[5] * r * .5, u = i[9] * r * .5 + i[11] * r * .5, c = [ n[1] * l + n[2] * u, n[5] * l + n[6] * u, n[9] * l + n[10] * u ], d = i[11], f = i[15], p = [ n[2] * d, n[6] * d, n[10] * d, n[14] * d + n[15] * f ], m = .7071067811 / Math.sqrt(s.dot(h, h) + s.dot(c, c));
        return p[0] *= m, p[1] *= m, p[2] *= m, p[3] *= m, p;
    }, d.prototype.getPixelFrom3D = function(t, e, r) {
        var i = h.create();
        h.multiply(this.projectionMatrix, this.viewMatrix, i);
        var n = [ t, e, r, 1 ];
        h.project(i, n);
        var o = Math.round(.5 * (1 + n[0]) * this.canvas.width), s = Math.round(.5 * (1 - n[1]) * this.canvas.height);
        return [ o, s ];
    }, d.prototype.createNonPowerOfTwoTextureFromImage = function(t, e) {
        var r = this.gl, i = r.createTexture();
        return r.bindTexture(r.TEXTURE_2D, i), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), 
        r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), 
        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), 
        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), 
        i;
    };
    var f = function(t, e) {
        t && (this.min = s.create(t)), e && (this.max = s.create(e));
    };
    f.prototype.extend = function(t, e, r) {
        this.min ? (t < this.min[0] && (this.min[0] = t), e < this.min[1] && (this.min[1] = e), 
        r < this.min[2] && (this.min[2] = r), t > this.max[0] && (this.max[0] = t), e > this.max[1] && (this.max[1] = e), 
        r > this.max[2] && (this.max[2] = r)) : (this.min = s.create(), this.max = s.create(), 
        this.min[0] = t, this.min[1] = e, this.min[2] = r, this.max[0] = t, this.max[1] = e, 
        this.max[2] = r);
    }, f.prototype.compute = function(t, e, r) {
        this.min || (this.min = s.create(), this.max = s.create()), this.min[0] = t[0], 
        this.min[1] = t[1], this.min[2] = t[2], this.max[0] = t[0], this.max[1] = t[1], 
        this.max[2] = t[2];
        for (var i = r || 3, n = e || t.length, o = i; o < n; o += i) for (var a = 0; a < 3; a++) t[o + a] < this.min[a] && (this.min[a] = t[o + a]), 
        t[o + a] > this.max[a] && (this.max[a] = t[o + a]);
    }, f.prototype.getCorner = function(t) {
        return [ 1 & t ? this.max[0] : this.min[0], 2 & t ? this.max[1] : this.min[1], 4 & t ? this.max[2] : this.min[2] ];
    }, f.prototype.getCenter = function() {
        return [ .5 * (this.max[0] + this.min[0]), .5 * (this.max[1] + this.min[1]), .5 * (this.max[2] + this.min[2]) ];
    }, f.prototype.getRadius = function() {
        var t = s.create();
        return s.subtract(this.max, this.min, t), .5 * s.length(t);
    };
    var p = function() {
        this.parent = null, this.parentIndex = -1, this.children = null, this.vertices = null, 
        this.texture = null, this.vertexBuffer = null, this.texTransform = [ 1, 1, 0, 0 ], 
        this.matrix = null, this.inverseMatrix = null, this.bbox = new f(), this.radius = 0, 
        this.distance = 0, this.closestPointToEye = [ 0, 0, 0 ], this.extension = {}, this.state = p.State.NONE, 
        this.config = null, this.imageSize = 256;
    };
    p.State = {
        ERROR: -10,
        NONE: 0,
        REQUESTED: 1,
        LOADING: 2,
        LOADED: 3
    }, p.prototype.computePosition = function(t, e) {
        var r = this.config.tesselation;
        t = Math.min(r - 1, Math.max(0, t)), e = Math.min(r - 1, Math.max(0, e));
        for (var i = Math.floor(e), n = e - i, o = Math.floor(t), s = t - o, a = this.config.vertexSize, h = a * (i * r + o), l = [ 0, 0, 0 ], u = 0; u < 3; u++) l[u] = (1 - n) * (1 - s) * this.vertices[h + u] + n * (1 - s) * this.vertices[h + a * r + u] + n * s * this.vertices[h + a * r + a + u] + (1 - n) * s * this.vertices[h + a + u];
        return l;
    }, p.prototype.initFromParent = function(t, e, r) {
        this.parent = t, this.parentIndex = 2 * r + e, this.matrix = t.matrix, this.inverseMatrix = t.inverseMatrix, 
        this.texture = t.texture, this.config = t.config, this.vertexBuffer = t.vertexBuffer;
        for (var i = this.config.tesselation, n = (i - 1) / 2, o = 0; o <= n; o++) for (var s = this.config.vertexSize * ((o + r * n) * i + e * n), a = 0; a <= n; a++) this.bbox.extend(t.vertices[s], t.vertices[s + 1], t.vertices[s + 2]), 
        s += this.config.vertexSize;
        this.radius = this.bbox.getRadius();
        for (var h in t.extension) {
            var l = t.extension[h];
            l.initChild && l.initChild(this, e, r);
        }
    }, p.prototype.needsToBeRefined = function(t) {
        if (this.distance < this.radius) return !0;
        var e = .25 * (this.bbox.max[0] - this.bbox.min[0] + (this.bbox.max[1] - this.bbox.min[1])) / this.imageSize, r = this.matrix, i = this.closestPointToEye, n = r[0] * i[0] + r[4] * i[1] + r[8] * i[2] + r[12], o = r[1] * i[0] + r[5] * i[1] + r[9] * i[2] + r[13], s = r[2] * i[0] + r[6] * i[1] + r[10] * i[2] + r[14], a = t.pixelSizeVector, h = e / (n * a[0] + o * a[1] + s * a[2] + a[3]);
        return Math.abs(h) > t.tileErrorTreshold;
    }, p.prototype.isCulled = function(t) {
        var e = this.inverseMatrix, r = t.eyePosition, i = e[0] * r[0] + e[4] * r[1] + e[8] * r[2] + e[12], n = e[1] * r[0] + e[5] * r[1] + e[9] * r[2] + e[13], o = e[2] * r[0] + e[6] * r[1] + e[10] * r[2] + e[14];
        if (this.distance = Math.sqrt(i * i + n * n + o * o), this.distance < this.radius) return this.distance = 0, 
        !1;
        var s = this.closestPointToEye;
        if (s[0] = Math.min(Math.max(i, this.bbox.min[0]), this.bbox.max[0]), s[1] = Math.min(Math.max(n, this.bbox.min[1]), this.bbox.max[1]), 
        s[2] = Math.min(Math.max(o, this.bbox.min[2]), this.bbox.max[2]), o < 0 && !this.config.coordinateSystem.isFlat) {
            var a = s[0], h = s[1], l = s[2] + this.config.coordinateSystem.radius, u = Math.sqrt(a * a + h * h + l * l);
            a /= u, h /= u, l /= u;
            var c = i - a * this.config.coordinateSystem.radius, d = n - h * this.config.coordinateSystem.radius, f = o - (l - 1) * this.config.coordinateSystem.radius, p = Math.sqrt(c * c + d * d + f * f), m = (c * a + d * h + f * l) / p;
            if (m *= this.config.cullSign, m < -.05) return !0;
        }
        var v = t.localFrustum;
        return v.inverseTransform(t.worldFrustum, this.matrix), !v.containsBoundingBox(this.bbox);
    }, p.prototype.dispose = function(t, e) {
        for (var r in this.extension) this.extension[r].dispose && this.extension[r].dispose(t, e);
        this.state == p.State.LOADED && (e.disposeGLBuffer(this.vertexBuffer), this.texture && e.disposeGLTexture(this.texture), 
        this.vertexBuffer = null, this.texture = null, this.parent = null, this.state = p.State.NONE);
    }, p.prototype.deleteChildren = function(t, e) {
        if (this.children) {
            for (var r = 0; r < 4; r++) this.children[r].deleteChildren(t, e), this.children[r].dispose(t, e);
            this.children = null;
        }
    }, p.prototype.buildSkirtVertices = function(t, e, r, i) {
        for (var n = this.vertices, o = .05 * this.radius, s = this.config.tesselation, a = 0; a < s; a++) {
            var h = n[e] - t[0], l = n[e + 1] - t[1], u = n[e + 2] - t[2], c = o / Math.sqrt(h * h + l * l + u * u);
            h *= c, l *= c, u *= c, n[i] = n[e] - h, n[i + 1] = n[e + 1] - l, n[i + 2] = n[e + 2] - u;
            for (var d = 3; d < this.config.vertexSize; d++) n[i + d] = n[e + d];
            i += this.config.vertexSize, e += r;
        }
    }, p.prototype.generateNormals = function() {
        for (var t = this.config.tesselation, e = this.config.vertexSize, r = e * t, i = 0, n = 0; n < t; n++) for (var o = n == t - 1 ? 0 : r, a = 0 == n ? 0 : -r, h = 0; h < t; h++) {
            var l = h == t - 1 ? 0 : e, u = 0 == h ? 0 : -e, c = [ this.vertices[i + l] - this.vertices[i + u], this.vertices[i + l + 1] - this.vertices[i + u + 1], this.vertices[i + l + 2] - this.vertices[i + u + 2] ], d = [ this.vertices[i + o] - this.vertices[i + a], this.vertices[i + o + 1] - this.vertices[i + a + 1], this.vertices[i + o + 2] - this.vertices[i + a + 2] ], f = s.cross(c, d, []);
            s.normalize(f), this.vertices[i + 3] = f[0], this.vertices[i + 4] = f[1], this.vertices[i + 5] = f[2], 
            i += e;
        }
    }, p.prototype.generate = function(t, e, r) {
        this.vertices = this.generateVertices(r);
        var i = this.config.tesselation, n = this.config.vertexSize;
        if (this.bbox.compute(this.vertices, n * i * i, n), this.radius = this.bbox.getRadius(), 
        this.config.normals && this.generateNormals(), this.config.skirt) {
            var o = [ 0, 0, 0 ];
            h.multiplyVec3(this.inverseMatrix, o);
            var s = n * (i * i);
            this.buildSkirtVertices(o, 0, n, s), s += n * i, this.buildSkirtVertices(o, n * (i * (i - 1)), n, s), 
            s += n * i, this.buildSkirtVertices(o, 0, n * i, s), s += n * i, this.buildSkirtVertices(o, n * (i - 1), n * i, s), 
            s += n * i, this.buildSkirtVertices(o, n * (i * (i - 1) / 2), n, s), s += n * i, 
            this.buildSkirtVertices(o, n * ((i - 1) / 2), n * i, s);
        }
        null != this.vertexBuffer && null == this.parent && t.disposeGLBuffer(this.vertexBuffer), 
        this.vertexBuffer = t.createGLBuffer(this.vertices), e && (this.texture = t.createGLTexture(e), 
        this.imageSize = this.config.imageSize), this.state = p.State.LOADED;
    };
    var m = {};
    m.inherits = function(t, e) {
        function r() {}
        r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
    };
    var v = function(t, e, r, i) {
        this.south = e, this.west = t, this.north = i, this.east = r;
    };
    v.prototype.getCenter = function() {
        return [ .5 * (this.east + this.west), .5 * (this.south + this.north), 0 ];
    }, v.prototype.getNorth = function() {
        return this.north;
    }, v.prototype.getSouth = function() {
        return this.south;
    }, v.prototype.getWest = function() {
        return this.west;
    }, v.prototype.getEast = function() {
        return this.east;
    }, v.prototype.computeFromCoordinates = function(t) {
        this.west = t[0][0], this.east = t[0][0], this.south = t[0][1], this.north = t[0][1];
        for (var e = 1; e < t.length; e++) this.west = Math.min(this.west, t[e][0]), this.east = Math.max(this.east, t[e][0]), 
        this.south = Math.min(this.south, t[e][1]), this.north = Math.max(this.north, t[e][1]);
    }, v.prototype.intersects = function(t) {
        return !(this.west >= t.east || this.east <= t.west) && !(this.south >= t.north || this.north <= t.south);
    }, v.prototype.intersectsGeometry = function(t) {
        var e = !1, r = new v(), i = t.coordinates;
        switch (t.type) {
          case "LineString":
            r.computeFromCoordinates(i), e |= this.intersects(r);
            break;

          case "Polygon":
            for (var n = 0; n < i.length && !e; n++) r.computeFromCoordinates(i[n]), e |= this.intersects(r);
            break;

          case "MultiLineString":
            for (var n = 0; n < i.length && !e; n++) r.computeFromCoordinates(i[n]), e |= this.intersects(r);
            break;

          case "MultiPolygon":
            for (var n = 0; n < i.length && !e; n++) for (var o = 0; o < i[n].length && !e; o++) r.computeFromCoordinates(i[n][o]), 
            e |= this.intersects(r);
        }
        return e;
    };
    var g = {
        ctab: [ 0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262, 263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283, 1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286, 1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520, 521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526, 527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546, 1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805, 1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816, 2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565, 2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584, 3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335, 3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314, 2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063, 2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082, 3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341, 3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855 ],
        utab: [ 0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277, 320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088, 1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301, 1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116, 4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369, 4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136, 5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381, 5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388, 16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469, 16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720, 16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473, 17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684, 17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485, 20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736, 20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817, 20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572, 21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781, 21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845 ],
        jrll: [ 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 ],
        jpll: [ 1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7 ],
        xoffset: [ -1, -1, 0, 1, 1, 1, 0, -1 ],
        yoffset: [ 0, 1, 1, 1, 0, -1, -1, -1 ],
        facearray: [ [ 8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9 ], [ 5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8 ], [ -1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1 ], [ 4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10 ], [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], [ 1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4 ], [ -1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1 ], [ 3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7 ], [ 2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3 ] ],
        swaparray: [ [ 0, 0, 3 ], [ 0, 0, 6 ], [ 0, 0, 0 ], [ 0, 0, 5 ], [ 0, 0, 0 ], [ 5, 0, 0 ], [ 0, 0, 0 ], [ 6, 0, 0 ], [ 3, 0, 0 ] ],
        swap_cycle: [ [], [ 0, 1, 8, 12, 16, 21, 40 ], [ 0, 1, 2, 40, 114 ], [ 0, 4, 160, 263 ], [ 0, 4, 30, 49, 51, 87, 526, 1027, 1105, 1387, 1807, 2637 ], [ 0, 8, 10, 18, 39, 74, 146, 307, 452, 4737 ], [ 0, 1, 2, 7, 9, 17, 80, 410, 1526, 1921, 32859, 33566, 38931 ], [ 0, 5, 6, 10, 12, 24, 27, 95, 372, 494, 924, 1409, 3492, 4248, 9137, 66043, 103369, 156899 ], [ 0, 1, 2, 3, 4, 45, 125, 351, 697, 24337, 102940, 266194, 341855, 419857 ], [ 0, 1, 2, 3, 9, 16, 1705, 2082, 2126, 8177, 12753, 15410, 52642, 80493, 83235, 88387, 99444, 1675361, 2495125 ], [ 0, 2, 6, 8, 9, 11, 20, 50, 93, 152, 183, 2137, 13671, 44794, 486954, 741908, 4803258, 5692573 ], [ 0, 1, 5, 6, 44, 53, 470, 2847, 3433, 4906, 13654, 14710, 400447, 1797382, 2744492, 18775974, 23541521 ], [ 0, 4, 9, 10, 16, 33, 83, 117, 318, 451, 5759, 10015, 128975, 171834, 211256, 347608, 1278690, 2154097, 2590798, 3427694, 5581717, 21012301, 27023976, 72522811, 95032729, 139166747, 171822389 ], [ 0, 5, 10, 267, 344, 363, 2968, 3159, 9083, 18437, 76602, 147614, 1246902, 1593138, 2035574, 6529391, 9511830, 11340287, 29565945, 281666026, 677946848 ] ]
    }, y = function(t, e) {
        this.low_ = 0 | t, this.high_ = 0 | e;
    };
    y.IntCache_ = {}, y.fromInt = function(t) {
        if (-128 <= t && t < 128) {
            var e = y.IntCache_[t];
            if (e) return e;
        }
        var r = new y(0 | t, t < 0 ? -1 : 0);
        return -128 <= t && t < 128 && (y.IntCache_[t] = r), r;
    }, y.fromNumber = function(t) {
        return isNaN(t) || !isFinite(t) ? y.ZERO : t <= -y.TWO_PWR_63_DBL_ ? y.MIN_VALUE : t + 1 >= y.TWO_PWR_63_DBL_ ? y.MAX_VALUE : t < 0 ? y.fromNumber(-t).negate() : new y(t % y.TWO_PWR_32_DBL_ | 0, t / y.TWO_PWR_32_DBL_ | 0);
    }, y.fromBits = function(t, e) {
        return new y(t, e);
    }, y.TWO_PWR_16_DBL_ = 65536, y.TWO_PWR_24_DBL_ = 1 << 24, y.TWO_PWR_32_DBL_ = y.TWO_PWR_16_DBL_ * y.TWO_PWR_16_DBL_, 
    y.TWO_PWR_64_DBL_ = y.TWO_PWR_32_DBL_ * y.TWO_PWR_32_DBL_, y.TWO_PWR_63_DBL_ = y.TWO_PWR_64_DBL_ / 2, 
    y.ZERO = y.fromInt(0), y.ONE = y.fromInt(1), y.MAX_VALUE = y.fromBits(-1, 2147483647), 
    y.MIN_VALUE = y.fromBits(0, -2147483648), y.TWO_PWR_24_ = y.fromInt(1 << 24), y.prototype.toInt = function() {
        return this.low_;
    }, y.prototype.toNumber = function() {
        return this.high_ * y.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    }, y.prototype.getLowBitsUnsigned = function() {
        return this.low_ >= 0 ? this.low_ : y.TWO_PWR_32_DBL_ + this.low_;
    }, y.prototype.isZero = function() {
        return 0 == this.high_ && 0 == this.low_;
    }, y.prototype.isNegative = function() {
        return this.high_ < 0;
    }, y.prototype.isOdd = function() {
        return 1 == (1 & this.low_);
    }, y.prototype.equals = function(t) {
        return this.high_ == t.high_ && this.low_ == t.low_;
    }, y.prototype.lessThan = function(t) {
        return this.compare(t) < 0;
    }, y.prototype.greaterThanOrEqual = function(t) {
        return this.compare(t) >= 0;
    }, y.prototype.compare = function(t) {
        if (this.equals(t)) return 0;
        var e = this.isNegative(), r = t.isNegative();
        return e && !r ? -1 : !e && r ? 1 : this.subtract(t).isNegative() ? -1 : 1;
    }, y.prototype.negate = function() {
        return this.equals(y.MIN_VALUE) ? y.MIN_VALUE : this.not().add(y.ONE);
    }, y.prototype.add = function(t) {
        var e = this.high_ >>> 16, r = 65535 & this.high_, i = this.low_ >>> 16, n = 65535 & this.low_, o = t.high_ >>> 16, s = 65535 & t.high_, a = t.low_ >>> 16, h = 65535 & t.low_, l = 0, u = 0, c = 0, d = 0;
        return d += n + h, c += d >>> 16, d &= 65535, c += i + a, u += c >>> 16, c &= 65535, 
        u += r + s, l += u >>> 16, u &= 65535, l += e + o, l &= 65535, y.fromBits(c << 16 | d, l << 16 | u);
    }, y.prototype.subtract = function(t) {
        return this.add(t.negate());
    }, y.prototype.multiply = function(t) {
        if (this.isZero()) return y.ZERO;
        if (t.isZero()) return y.ZERO;
        if (this.equals(y.MIN_VALUE)) return t.isOdd() ? y.MIN_VALUE : y.ZERO;
        if (t.equals(y.MIN_VALUE)) return this.isOdd() ? y.MIN_VALUE : y.ZERO;
        if (this.isNegative()) return t.isNegative() ? this.negate().multiply(t.negate()) : this.negate().multiply(t).negate();
        if (t.isNegative()) return this.multiply(t.negate()).negate();
        if (this.lessThan(y.TWO_PWR_24_) && t.lessThan(y.TWO_PWR_24_)) return y.fromNumber(this.toNumber() * t.toNumber());
        var e = this.high_ >>> 16, r = 65535 & this.high_, i = this.low_ >>> 16, n = 65535 & this.low_, o = t.high_ >>> 16, s = 65535 & t.high_, a = t.low_ >>> 16, h = 65535 & t.low_, l = 0, u = 0, c = 0, d = 0;
        return d += n * h, c += d >>> 16, d &= 65535, c += i * h, u += c >>> 16, c &= 65535, 
        c += n * a, u += c >>> 16, c &= 65535, u += r * h, l += u >>> 16, u &= 65535, u += i * a, 
        l += u >>> 16, u &= 65535, u += n * s, l += u >>> 16, u &= 65535, l += e * h + r * a + i * s + n * o, 
        l &= 65535, y.fromBits(c << 16 | d, l << 16 | u);
    }, y.prototype.not = function() {
        return y.fromBits(~this.low_, ~this.high_);
    }, y.prototype.and = function(t) {
        return y.fromBits(this.low_ & t.low_, this.high_ & t.high_);
    }, y.prototype.or = function(t) {
        return y.fromBits(this.low_ | t.low_, this.high_ | t.high_);
    }, y.prototype.shiftRightUnsigned = function(t) {
        if (t &= 63, 0 == t) return this;
        var e = this.high_;
        if (t < 32) {
            var r = this.low_;
            return y.fromBits(r >>> t | e << 32 - t, e >>> t);
        }
        return 32 == t ? y.fromBits(e, 0) : y.fromBits(e >>> t - 32, 0);
    };
    var x, b, T = function(t) {
        for (np = t.length, x = s.add2(t[0], t[1]), x = s.normalize2(x), b = s.dot2(t[0], x), 
        i = 2; i < np; ++i) s.dot2(t[i], x) < b && this.getCircle(t, i);
    };
    T.prototype.getCircle = function(t, e, r) {
        for (x = s.add2(t[e], t[r]), x = s.normalize2(x), b = s.dot2(t[e], x), i = 0; i < e; ++i) if (s.dot2(t[i], x) < b) {
            var n = s.subtract2(t[e], t[i]), o = s.subtract2(t[r], t[i]);
            x = s.cross2(n, o), x = s.normalize2(x), b = s.dot2(t[e], x), b < 0 && (x = s.flip(x), 
            b = -b);
        }
    }, T.prototype.getCircle = function(t, e) {
        for (x = s.add2(t[0], t[e]), x = s.normalize2(x), b = s.dot2(t[0], x), i = 1; i < e; ++i) s.dot2(t[i], x) < b && this.getCircle(t, i, e);
    }, T.prototype.getCenter = function() {
        return x;
    }, T.prototype.getCosRad = function() {
        return b;
    };
    var M = 1.570796325, R = function(t, e) {
        t < 0 && (t += 360);
        var r = t * Math.PI / 180, i = (-e + 90) * Math.PI / 180;
        return [ r, i ];
    }, S = function(t, e) {
        if (t >= 0) return t < e ? t : t % e;
        var r = t % e + e;
        return r == e ? 0 : r;
    }, w = function(t) {
        return g.utab[255 & t] | g.utab[t >>> 8 & 255] << 16 | g.utab[t >>> 16 & 255] << 32 | g.utab[t >>> 24 & 255] << 48;
    }, P = function(t, e, r, i) {
        return (r << 2 * i) + w(t) + (w(e) << 1);
    }, E = function(t, e, r) {
        var i = Math.pow(2, t), n = Math.cos(r), e = e, o = {
            phi: e,
            theta: r,
            z: n
        };
        Math.abs(n) > .9 && (o.sth = Math.sin(r), o.have_sth = !0);
        var s = 2 / Math.PI, a = S(e * s, 4), h = Math.abs(n);
        if (h <= 2 / 3) {
            var l, u = i * (.5 + a), c = i * (.75 * n), d = y.fromNumber(u - c), f = y.fromNumber(u + c), p = d.shiftRightUnsigned(t), m = f.shiftRightUnsigned(t);
            l = p.equals(m) ? p.or(y.fromInt(4)) : p.lessThan(m) ? p : m.add(y.fromInt(8));
            var v = y.fromNumber(i - 1), g = f.and(v), x = v.subtract(d.and(v));
            return P(g.toInt(), x.toInt(), l.toInt(), t);
        }
        var b = parseInt(Math.min(3, parseInt(a))), T = a - b, _ = h < .9 || !o.have_sth ? i * Math.sqrt(3 * (1 - h)) : i * o.sth / Math.sqrt((1 + h) / 3), d = y.fromNumber(T * _), f = y.fromNumber((1 - T) * _), M = y.fromNumber(i), v = y.fromNumber(i - 1), R = y.fromInt(1);
        return d.greaterThanOrEqual(M) && (d = v), f.greaterThanOrEqual(M) && (f = v), n >= 0 ? P(M.subtract(f).subtract(R).toInt(), M.subtract(d).subtract(R).toInt(), b, t) : P(d.toInt(), f.toInt(), b + 8, t);
    }, C = function(t) {
        this.p = Array(t), this.o = Array(t);
        for (var e = 0; e < this.p.length; e++) this.p[e] = 0, this.o[e] = 0;
        this.s = this.m = 0;
    };
    C.prototype.push = function(t, e) {
        this.p[this.s] = t, this.o[this.s] = e, ++this.s;
    }, C.prototype.otop = function() {
        return this.o[this.s - 1];
    }, C.prototype.ptop = function() {
        return this.p[this.s - 1];
    }, C.prototype.pop = function() {
        this.s--;
    }, C.prototype.popToMark = function() {
        this.s = this.m;
    }, C.prototype.mark = function() {
        this.m = this.s;
    }, C.prototype.size = function() {
        return this.s;
    };
    var I = {
        init: function(t) {
            this.order_max = 29, this.bn = [], this.nside = null;
            try {
                for (var e = 0; e <= this.order_max; ++e) this.bn[e] = this.createBoundaries(1 << e, "NESTED");
            } catch (t) {}
        },
        createBoundaries: function(t, e) {
            return this.nside = t - 1, this.calculateBoundaries(t, e);
        },
        compress_bits: function(t) {
            var e = y.fromNumber(t), r = y.fromNumber(0x5555555555555), i = e.and(r), n = i.shiftRightUnsigned(15);
            i = i.or(n);
            var o = i.and(y.fromNumber(65535)).toInt(), s = i.shiftRightUnsigned(32), a = s.and(y.fromNumber(65535)).toInt();
            return g.ctab[255 & o] | g.ctab[o >>> 8] << 4 | g.ctab[255 & a] << 16 | g.ctab[a >>> 8] << 20;
        },
        fxyf: function(t, e, r) {
            var i, n = g.jrll[r] - t - e, o = 0, s = 0, a = 0, h = !1;
            if (n < 1) {
                i = n;
                var l = i * i / 3;
                o = 1 - l, o > .99 && (a = Math.sqrt(l * (2 - l)), h = !0);
            } else if (n > 3) {
                i = 4 - n;
                var l = i * i / 3;
                o = l - 1, o < -.99 && (a = Math.sqrt(l * (2 - l)), h = !0);
            } else i = 1, o = 2 * (2 - n) / 3;
            var l = g.jpll[r] * i + t - e;
            l < 0 && (l += 8), l >= 8 && (l -= 8), s = i < 1e-15 ? 0 : .5 * M * l / i;
            var u = h ? a : Math.sqrt((1 - o) * (1 + o));
            return [ u * Math.cos(s), u * Math.sin(s), o ];
        },
        maxPixrad: function(t, e) {
            var r = Math.pow(2, t), i = s.createZPhi(2 / 3, Math.PI / e), n = 1 - 1 / r;
            n *= n;
            var o = s.createZPhi(1 - n / 3, 0);
            return s.angle2(i, o);
        },
        pix2vec: function(t, e) {
            var r = this.pix2loc(t, e), i = r.have_sth ? r.sth : Math.sqrt((1 - r.z) * (1 + r.z));
            return s.createFrom(i * Math.cos(r.phi), i * Math.sin(r.phi), r.z);
        },
        pix2loc: function(t, e) {
            var r, i = {
                phi: null,
                sth: 0,
                have_sth: !1,
                z: null
            }, n = this.nest2xyf(t, e.npface, e.order), o = (g.jrll[n.face] << e.order) - n.ix - n.iy - 1;
            if (o < e.nside) {
                r = o;
                var s = r * r * e.fact2;
                i.z = 1 - s, i.z > .99 && (i.sth = Math.sqrt(s * (2 - s)), i.have_sth = !0);
            } else if (o > e.nl3) {
                r = e.nl4 - o;
                var s = r * r * e.fact2;
                i.z = s - 1, i.z < -.99 && (i.sth = Math.sqrt(s * (2 - s)), i.have_sth = !0);
            } else r = e.nside, i.z = (e.nl2 - o) * e.fact1;
            var s = g.jpll[n.face] * r + n.ix - n.iy;
            return s < 0 && (s += 8 * r), i.phi = r == e.nside ? .75 * M * s * e.fact1 : .5 * M * s / r, 
            i;
        },
        nest2xyf: function(t, e, r) {
            var i = t & e - 1, n = I.compress_bits(i), o = I.compress_bits(i >>> 1), s = t >>> 2 * r;
            return {
                ix: n,
                iy: o,
                face: s
            };
        },
        nside2order: function(t) {
            for (var e = 0; t > 65535; ) e += 16, t >>>= 16;
            return t > 255 && (e |= 8, t >>>= 8), t > 15 && (e |= 4, t >>>= 4), t > 3 && (e |= 2, 
            t >>>= 2), t > 1 && (e |= 1), e;
        },
        calculateBoundaries: function(t, e) {
            if (this.nside != t) {
                this.nside = t;
                var r = this.nside2order(t);
                if ("NESTED" == e && r < 0) throw new Exception("Nside must be a power of 2 for NESTED scheme");
                var i = 2 * this.nside, n = 3 * this.nside, o = 4 * this.nside, s = this.nside * this.nside, a = 2 * this.nside * (this.nside - 1), h = 12 * s, l = 4 / h, u = (this.nside << 1) * l;
                return {
                    order: r,
                    nside: this.nside,
                    scheme: e,
                    nl2: i,
                    nl3: n,
                    nl4: o,
                    npface: s,
                    ncap: a,
                    npix: h,
                    fact1: u,
                    fact2: l
                };
            }
        },
        convertPolygonToHealpixOrder: function(t, e, r) {
            var i = [], n = e || 4, o = r || 5;
            return _.each(t, function(t) {
                var e = Math.PI / 180, r = Math.cos(t[1] * e), n = Math.cos(t[0] * e) * r, o = Math.sin(t[0] * e) * r, s = Math.sin(t[1] * e), a = Math.atan2(Math.sqrt(n * n + o * o), s), h = Math.atan2(o, n);
                h < 0 && (h += 2 * Math.PI), h >= 2 * Math.PI && (h -= 2 * Math.PI), i.push({
                    theta: a,
                    phi: h
                });
            }), this.queryPolygonInclusive(i, n, o);
        },
        queryPolygonInclusive: function(t, e, r) {
            Math.PI = 3.141592653589793;
            var i = Math.PI / 2, n = 0 != e, o = t.length, a = n ? o + 1 : o;
            if (o < 3) return void alert("not enough vertices in polygon");
            for (var h = Array(o), l = 0; l < o; ++l) h[l] = s.createPhiTheta(t[l].phi, t[l].theta);
            for (var u = Array(a), c = 0, l = 0; l < o; ++l) {
                u[l] = s.cross2(h[l], h[(l + 1) % o]);
                var d = s.dot2(u[l], h[(l + 2) % o]);
                0 == l && (c = d < 0 ? -1 : 1), u[l] = s.scale2(u[l], c / s.length2(u[l]));
            }
            var f = Array(a);
            if (this.fill(f, i), n) {
                var p = new T(h);
                u[o] = p.getCenter(), f[o] = Math.acos(p.getCosRad());
            }
            var m = this.queryMultiDisc(u, f, e, r);
            return console.dir(m), m;
        },
        fill: function(t, e) {
            for (var r = 0, i = t.length; r < i; r++) t[r] = e;
        },
        queryMultiDisc: function(t, e, r, i) {
            var n = i, o = 0 != r, a = t.length, h = [], l = 0;
            o && (l = this.ilog2(r));
            for (var u = n + l, c = Array(u + 1), d = 0; d < u + 1; d++) {
                c[d] = Array(a);
                for (var f = 0; f < a; f++) c[d][f] = Array(3);
            }
            var p = {
                order: n
            };
            I.init(p);
            for (var m = 0; m <= u; ++m) for (var v = I.bn[m], g = I.maxPixrad(m, v.nl4), d = 0; d < a; ++d) c[m][d][0] = e[d] + g > Math.PI ? -1 : Math.cos(e[d] + g), 
            c[m][d][1] = 0 == m ? Math.cos(e[d]) : c[0][d][1], c[m][d][2] = e[d] - g < 0 ? 1 : Math.cos(e[d] - g);
            for (var y = new C(12 + 3 * u), d = 0; d < 12; d++) y.push(11 - d, 0);
            for (;y.size() > 0; ) {
                var x = y.ptop(), m = y.otop();
                y.pop();
                for (var v = I.bn[m], b = I.pix2vec(x, v), T = 3, d = 0; d < a && T > 0; ++d) for (var _ = s.dot2(b, t[d]), M = 0; M < T; ++M) _ < c[m][d][M] && (T = M);
                T > 0 && this.check_pixel(m, u, T, h, x, y, o, i);
            }
            return h;
        },
        check_pixel: function(t, e, r, i, n, o, s, a) {
            var h = a;
            if (0 != r) if (t < h) if (r >= 3) for (var l = 2 * (h - t), u = n << l, c = n + 1 << l, d = u; d <= c; d++) i.push(d); else for (var d = 0; d < 4; ++d) o.push(4 * n + 3 - d, t + 1); else if (t > h) if (r >= 2) i.push(n >>> 2 * (t - h)), 
            o.popToMark(); else if (t < e) for (var d = 0; d < 4; ++d) o.push(4 * n + 3 - d, t + 1); else i.push(n >>> 2 * (t - h)), 
            o.popToMark(); else if (r >= 2) i.push(n); else if (s) if (h < e) {
                o.mark();
                for (var d = 0; d < 4; ++d) o.push(4 * n + 3 - d, t + 1);
            } else i.push(n);
        },
        ilog2: function(t) {
            for (var e = 0; t > 65535; ) e += 16, t >>>= 16;
            return t > 255 && (e |= 8, t >>>= 8), t > 15 && (e |= 4, t >>>= 4), t > 3 && (e |= 2, 
            t >>>= 2), t > 1 && (e |= 1), e;
        },
        lonLat2pix: function(t, e, r) {
            var i = R(e, r);
            return E(t, i[0], i[1]);
        },
        getChildren: function(t) {
            return [ 4 * t, 4 * t + 1, 4 * t + 2, 4 * t + 3 ];
        },
        uniq2hpix: function(t, e) {
            null == e && (e = []), e[0] = I.log2(t / 4) / 2;
            var r = I.pow2(e[0]);
            return e[1] = t - 4 * r * r, e[0] = parseInt(e[0]), e;
        },
        log2: function(t) {
            for (var e = 0; t >>> ++e > 0; ) ;
            return --e;
        },
        pow2: function(t) {
            return 1 << t;
        },
        getPixRes: function(t) {
            var e = 648e3 / Math.PI;
            return e * Math.sqrt(4 * Math.PI / (12 * t * t));
        }
    }, L = function(t, e) {
        this.level0NumTilesX = t, this.level0NumTilesY = e;
    };
    L.prototype.generateLevelZeroTiles = function(t) {
        t.skirt = 1, t.cullSign = 1, t.srs = "EPSG:4326";
        for (var e = [], r = 180 / this.level0NumTilesY, i = 360 / this.level0NumTilesX, n = 0; n < this.level0NumTilesY; n++) for (var o = 0; o < this.level0NumTilesX; o++) {
            var s = new v(-180 + o * i, 90 - (n + 1) * r, -180 + (o + 1) * i, 90 - n * r), a = new A(s, 0, o, n);
            a.config = t, e.push(a);
        }
        return e;
    };
    var F = function(t) {
        var e, r = !0;
        switch (t.type) {
          case "Point":
            return e = t.coordinates, [ e[0], e[1], e[0], e[1] ];

          case "MultiPoint":
            e = t.coordinates, r = !1;
            break;

          case "Polygon":
            e = t.coordinates[0];
            break;

          case "MultiPolygon":
            e = t.coordinates[0][0];
            break;

          case "LineString":
            e = t.coordinates;
            break;

          case "MultiLineString":
            e = t.coordinates[0];
        }
        if (e && 0 != e.length) {
            for (var i = e[0][0], n = e[0][1], o = e[0][0], s = e[0][1], a = "MultiPolygon" == t.type || "MultiLineString" == t.type ? t.coordinates.length : 1, h = 0; h < a; h++) {
                switch (t.type) {
                  case "MultiPolygon":
                    e = t.coordinates[h][0];
                    break;

                  case "MultiLineString":
                    e = t.coordinates[h];
                }
                for (var l = 0; l < e.length; l++) i = Math.min(i, e[l][0]), n = Math.min(n, e[l][1]), 
                o = Math.max(o, e[l][0]), s = Math.max(s, e[l][1]), r && l > 0 && Math.abs(e[l - 1][0] - e[l][0]) > 180 && (i = -180, 
                o = 180);
            }
            return [ i, n, o, s ];
        }
    };
    L.prototype._lon2LevelZeroIndex = function(t) {
        return Math.min(this.level0NumTilesX - 1, Math.floor((t + 180) * this.level0NumTilesX / 360));
    }, L.prototype._lat2LevelZeroIndex = function(t) {
        return Math.min(this.level0NumTilesY - 1, Math.floor((90 - t) * this.level0NumTilesY / 180));
    }, L.prototype.lonlat2LevelZeroIndex = function(t, e) {
        return this._lat2LevelZeroIndex(e) * this.level0NumTilesX + this._lon2LevelZeroIndex(t);
    }, L.prototype.getOverlappedLevelZeroTiles = function(t) {
        var e = [], r = F(t);
        if (r) for (var i = this._lon2LevelZeroIndex(r[0]), n = this._lat2LevelZeroIndex(r[3]), o = this._lon2LevelZeroIndex(r[2]), s = this._lat2LevelZeroIndex(r[1]), a = n; a <= s; a++) for (var h = i; h <= o; h++) e.push(a * this.level0NumTilesX + h);
        return e;
    }, L.prototype.findInsideTile = function(t, e, r) {
        var i = mizar.getScene().coordinateSystem;
        if ("EQ" != i.type) {
            var n = i.convert([ t, e ], "EQ", i.type);
            t = n[0], e = n[1];
        }
        for (var o = 0; o < r.length; o++) {
            var s = r[o], a = I.lonLat2pix(s.order, t, e);
            if (a == s.pixelIndex) return s;
        }
        return null;
    };
    var A = function(t, e, r, i) {
        p.prototype.constructor.call(this), this.bound = this.geoBound = t, this.level = e, 
        this.x = r, this.y = i;
    };
    A.prototype = new p(), A.prototype.getElevation = function(t, e) {
        var r = (t - this.geoBound.west) / (this.geoBound.east - this.geoBound.west), i = (e - this.geoBound.north) / (this.geoBound.south - this.geoBound.north), n = 2 * (i >= 1 ? 1 : Math.floor(2 * i)) + Math.floor(2 * r);
        if (this.children && this.children[n].state == p.State.LOADED) return this.children[n].getElevation(t, e);
        var o = this.config.tesselation, s = Math.floor(r * o), a = Math.floor(i * o), l = this.config.vertexSize * (a * o + s), u = [ this.vertices[l], this.vertices[l + 1], this.vertices[l + 2] ];
        h.multiplyVec3(this.matrix, u);
        var c = this.config.coordinateSystem.from3DToGeo(u);
        return c[2];
    }, A.prototype.createChildren = function() {
        var t = .5 * (this.geoBound.east + this.geoBound.west), e = .5 * (this.geoBound.north + this.geoBound.south), r = this.level + 1, i = new A(new v(this.geoBound.west, e, t, this.geoBound.north), r, 2 * this.x, 2 * this.y), n = new A(new v(t, e, this.geoBound.east, this.geoBound.north), r, 2 * this.x + 1, 2 * this.y), o = new A(new v(this.geoBound.west, this.geoBound.south, t, e), r, 2 * this.x, 2 * this.y + 1), s = new A(new v(t, this.geoBound.south, this.geoBound.east, e), r, 2 * this.x + 1, 2 * this.y + 1);
        i.initFromParent(this, 0, 0), n.initFromParent(this, 1, 0), o.initFromParent(this, 0, 1), 
        s.initFromParent(this, 1, 1), this.children = [ i, n, o, s ];
    }, A.prototype.lonlat2tile = function(t) {
        for (var e = this.geoBound.east - this.geoBound.west, r = this.geoBound.south - this.geoBound.north, i = this.config.tesselation - 1, n = [], o = 0; o < t.length; o++) {
            var s = i * (t[o][0] - this.geoBound.west) / e, a = i * (t[o][1] - this.geoBound.north) / r;
            n.push([ s, a ]);
        }
        return n;
    }, A.prototype.generateVertices = function(t) {
        this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
        var e = h.create();
        h.inverse(this.matrix, e), this.inverseMatrix = e;
        for (var r = this.config.vertexSize, i = this.config.tesselation, n = new Float32Array(r * i * (i + 6)), o = (this.geoBound.east - this.geoBound.west) / (i - 1), s = (this.geoBound.south - this.geoBound.north) / (i - 1), a = (this.config.coordinateSystem.radius, 
        this.config.coordinateSystem.heightScale, 0), l = this.geoBound.north, u = [ 0, 0, 0 ], c = 0; c < i; c++) {
            for (var d = this.geoBound.west, f = 0; f < i; f++) {
                var p = t ? t[a] : 0;
                this.config.coordinateSystem.fromGeoTo3D([ d, l, p ], u);
                var m = u[0], v = u[1], g = u[2], y = a * r;
                n[y] = e[0] * m + e[4] * v + e[8] * g + e[12], n[y + 1] = e[1] * m + e[5] * v + e[9] * g + e[13], 
                n[y + 2] = e[2] * m + e[6] * v + e[10] * g + e[14], a++, d += o;
            }
            l += s;
        }
        return n;
    };
    var D = function(t) {
        var e = t.gl, r = {}, i = [], n = this, o = e.getExtension("OES_texture_float_linear"), s = o ? e.LINEAR : e.NEAREST;
        this.numCreatedTextures = 0, this.numReusedTextures = 0;
        var a = function(t, r) {
            var i = e.createTexture();
            return e.bindTexture(e.TEXTURE_2D, i), "byte" == t.dataType ? (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), 
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR_MIPMAP_LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), 
            e.generateMipmap(e.TEXTURE_2D)) : (e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.width, t.height, 0, e.LUMINANCE, e.FLOAT, t.typedArray), 
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s)), 
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), 
            i.pool = r, n.numCreatedTextures++, i;
        }, h = function(t, r) {
            var i = r.pop();
            return e.bindTexture(e.TEXTURE_2D, i), "byte" == t.dataType ? (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), 
            e.generateMipmap(e.TEXTURE_2D)) : e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.width, t.height, 0, e.LUMINANCE, e.FLOAT, t.typedArray), 
            n.numReusedTextures++, i;
        }, l = function(t) {
            var e = t.dataType + t.width;
            return r[e] || (r[e] = []), r[e];
        };
        this.createGLTexture = function(t) {
            var e = l(t);
            return e.length > 0 ? h(t, e) : a(t, e);
        }, this.createGLBuffer = function(t) {
            var r;
            return r = i.length > 0 ? i.pop() : e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, r), 
            e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), r;
        }, this.disposeGLTexture = function(t) {
            t.pool.push(t);
        }, this.disposeGLBuffer = function(t) {
            i.push(t);
        }, this.disposeAll = function() {
            for (var t in r) if (r.hasOwnProperty(t)) for (var n = r[t], o = 0; o < n.length; o++) e.deleteTexture(n[o]);
            r = {};
            for (var o = 0; o < i.length; o++) e.deleteBuffer(i[o]);
            i.length = 0;
        };
    }, B = function(t) {
        this.successCallback = t.successCallback, this.failCallback = t.failCallback, this.abortCallback = t.abortCallback, 
        this.image = null;
    };
    B.prototype.send = function(t, e) {
        this.image = new Image(), this.image.crossOrigin = e, this.image.dataType = "byte";
        var r = this;
        this.image.onload = function() {
            var t = 0 != r.image.naturalWidth && r.image.complete;
            t && r.successCallback.call(r);
        }, this.image.onerror = this.failCallback.bind(this), this.image.src = t;
    }, B.prototype.abort = function() {
        this.abortCallback && this.abortCallback(this), this.image.src = "";
    };
    var O = function(t) {
        var e, r = !1, i = !0, n = new XMLHttpRequest();
        this.tile = null, this.elevations = null, this.image = null;
        var o = this;
        n.onreadystatechange = function(t) {
            4 == n.readyState && (200 == n.status ? l() : u());
        };
        var s = function() {
            r || (r = !0, i && (t.imageryProvider && t.imageryProvider.handleImage && t.imageryProvider.handleImage(e), 
            t.pendingRequests.splice(t.pendingRequests.indexOf(o), 1), t.completedRequests.push(o), 
            t.renderContext.requestFrame()), o.image = e.image);
        }, a = function() {
            o.tile.state = p.State.ERROR, t.pendingRequests.splice(t.pendingRequests.indexOf(o), 1), 
            t.availableRequests.push(o);
        }, h = function() {
            o.tile.state = p.State.NONE, t.pendingRequests.splice(t.pendingRequests.indexOf(o), 1), 
            t.availableRequests.push(o);
        }, l = function() {
            o.elevations = t.elevationProvider.parseElevations(n.responseText), i = !0, r && (t.pendingRequests.splice(t.pendingRequests.indexOf(o), 1), 
            t.completedRequests.push(o), t.renderContext.requestFrame());
        }, u = function() {
            o.elevations = null, i = !0, r && (t.pendingRequests.splice(t.pendingRequests.indexOf(o), 1), 
            t.completedRequests.push(o), t.renderContext.requestFrame());
        };
        this.launch = function(l) {
            if (l.state = p.State.LOADING, this.tile = l, t.pendingRequests.push(this), this.image = null, 
            this.elevations = null, t.elevationProvider) {
                i = !1, n.open("GET", t.elevationProvider.getUrl(l));
                var u = "use-credentials" == t.elevationProvider.crossOrigin;
                n.withCredentials = u, n.send();
            } else i = !0;
            if (t.imageryProvider) {
                e || (e = new B({
                    successCallback: function() {
                        s(), t.imageryProvider.cache && t.imageryProvider.cache.storeInCache(o);
                    },
                    failCallback: a,
                    abortCallback: h
                }));
                var c;
                t.imageryProvider.cache && (c = c = t.imageryProvider.cache.getFromCache(l)), r = !1, 
                c ? (e.image = c.image, s()) : e.send(t.imageryProvider.getUrl(l), t.imageryProvider.crossOrigin);
            } else r = !0;
            t.imageryProvider || t.elevationProvider || (t.pendingRequests.splice(t.pendingRequests.indexOf(this), 1), 
            t.completedRequests.push(this));
        }, this.abort = function() {
            e && e.abort();
        };
    }, N = function(t, e) {
        this.renderContext = t, this.config = e, this.solidIndexBuffer = null, this.subSolidIndexBuffer = [ null, null, null, null ], 
        this.subIndices = [ null, null, null, null ];
    };
    N.prototype.reset = function() {
        for (var t = this.renderContext.gl, e = 0; e < 4; e++) this.subSolidIndexBuffer[e] && (t.deleteBuffer(this.subSolidIndexBuffer[e]), 
        this.subSolidIndexBuffer[e] = null);
        this.solidIndexBuffer && (t.deleteBuffer(this.solidIndexBuffer), this.solidIndexBuffer = null);
    }, N.prototype.getSubSolid = function(t) {
        if (null == this.subSolidIndexBuffer[t]) {
            for (var e = t % 2, r = Math.floor(t / 2), i = this.config.tesselation, n = (i - 1) / 2, o = [], s = n * r; s < n * (r + 1); s++) for (var a = n * e; a < n * (e + 1); a++) o.push(s * i + a), 
            o.push((s + 1) * i + a), o.push(s * i + a + 1), o.push(s * i + a + 1), o.push((s + 1) * i + a), 
            o.push((s + 1) * i + a + 1);
            if (this.subIndices[t] = o, this.config.skirt) {
                for (var h = 0 == r ? i * i : i * i + 4 * i, l = 0 == r ? 0 : n * i, s = n * e; s < n * (e + 1); s++) o.push(h + s), 
                o.push(l + s), o.push(h + s + 1), o.push(h + s + 1), o.push(l + s), o.push(l + s + 1);
                h = 0 == r ? i * i + 4 * i : i * i + i, l = 0 == r ? n * i : (i - 1) * i;
                for (var s = n * e; s < n * (e + 1); s++) o.push(l + s), o.push(h + s), o.push(l + s + 1), 
                o.push(l + s + 1), o.push(h + s), o.push(h + s + 1);
                h = 0 == e ? i * i + 2 * i : i * i + 5 * i, l = 0 == e ? 0 : n;
                for (var a = n * r; a < n * (r + 1); a++) o.push(h + a), o.push(h + a + 1), o.push(l + a * i), 
                o.push(l + a * i), o.push(h + a + 1), o.push(l + (a + 1) * i);
                h = 0 == e ? i * i + 5 * i : i * i + 3 * i, l = 0 == e ? n : i - 1;
                for (var a = n * r; a < n * (r + 1); a++) o.push(a * i + l), o.push((a + 1) * i + l), 
                o.push(h + a), o.push(h + a), o.push((a + 1) * i + l), o.push(h + a + 1);
            }
            var u = this.renderContext.gl, c = u.createBuffer();
            u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, c), u.bufferData(u.ELEMENT_ARRAY_BUFFER, new Uint16Array(o), u.STATIC_DRAW), 
            c.numIndices = o.length, this.subSolidIndexBuffer[t] = c;
        }
        return this.subSolidIndexBuffer[t];
    }, N.prototype.getSolid = function() {
        if (null == this.solidIndexBuffer) {
            for (var t = this.config.tesselation, e = [], r = 0; r < t - 1; r++) for (var i = 0; i < t - 1; i++) e.push(r * t + i), 
            e.push((r + 1) * t + i), e.push(r * t + i + 1), e.push(r * t + i + 1), e.push((r + 1) * t + i), 
            e.push((r + 1) * t + i + 1);
            if (this.config.skirt) {
                for (var n = t * t, i = 0; i < t - 1; i++) e.push(n + i), e.push(i), e.push(n + i + 1), 
                e.push(n + i + 1), e.push(i), e.push(i + 1);
                n += t;
                for (var i = 0; i < t - 1; i++) e.push((t - 1) * t + i), e.push(n + i), e.push((t - 1) * t + i + 1), 
                e.push((t - 1) * t + i + 1), e.push(n + i), e.push(n + i + 1);
                n += t;
                for (var r = 0; r < t - 1; r++) e.push(n + r), e.push(n + r + 1), e.push(r * t), 
                e.push(r * t), e.push(n + r + 1), e.push((r + 1) * t);
                n += t;
                for (var r = 0; r < t - 1; r++) e.push(r * t + t - 1), e.push((r + 1) * t + t - 1), 
                e.push(n + r), e.push(n + r), e.push((r + 1) * t + t - 1), e.push(n + r + 1);
            }
            var o = this.renderContext.gl, s = o.createBuffer();
            o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, s), o.bufferData(o.ELEMENT_ARRAY_BUFFER, new Uint16Array(e), o.STATIC_DRAW), 
            this.numIndices = e.length, this.solidIndexBuffer = s, this.solidIndexBuffer.numIndices = e.length;
        }
        return this.solidIndexBuffer;
    };
    var k = function(t) {
        this.renderContext = t, this.glProgram = null, this.attributes = {}, this.uniforms = {}, 
        this.numActiveAttribArray = 0;
    };
    k.prototype.createShader = function(t, e) {
        var r = this.renderContext.gl, i = r.createShader(t);
        return r.shaderSource(i, e), r.compileShader(i), r.getShaderParameter(i, r.COMPILE_STATUS) ? i : (console.log("Shader compilation error: " + r.getShaderInfoLog(i)), 
        console.log(e), r.deleteShader(i), null);
    }, k.prototype.createFromSource = function(t, e) {
        var r = this.renderContext.gl, i = this.createShader(r.VERTEX_SHADER, t), n = this.createShader(r.FRAGMENT_SHADER, e);
        if (null == i || null == n) return !1;
        if (this.glProgram = r.createProgram(), r.attachShader(this.glProgram, i), r.attachShader(this.glProgram, n), 
        r.linkProgram(this.glProgram), !r.getProgramParameter(this.glProgram, r.LINK_STATUS)) return console.log("Program link error: " + r.getProgramInfoLog(this.glProgram)), 
        r.deleteShader(i), r.deleteShader(n), r.deleteProgram(this.glProgram), this.glProgram = null, 
        !1;
        var o = r.getProgramParameter(this.glProgram, r.ACTIVE_ATTRIBUTES);
        this.numActiveAttribArray = 0;
        for (var s = 0; s < o; ++s) {
            var a = r.getActiveAttrib(this.glProgram, s), h = r.getAttribLocation(this.glProgram, a.name);
            this.attributes[a.name] = h, h + 1 > this.numActiveAttribArray && (this.numActiveAttribArray = h + 1);
        }
        for (var l = r.getProgramParameter(this.glProgram, r.ACTIVE_UNIFORMS), s = 0; s < l; ++s) {
            var u = r.getActiveUniform(this.glProgram, s);
            this.uniforms[u.name] = r.getUniformLocation(this.glProgram, u.name);
        }
        return !0;
    }, k.prototype.loadFromFile = function(t, e) {
        var r = new XMLHttpRequest();
        r.open("get", this.renderContext.shadersPath + t, !1), r.send(null);
        var i = r.responseText;
        r.open("get", this.renderContext.shadersPath + e, !1), r.send(null);
        var n = r.responseText;
        return this.createFromSource(i, n);
    }, k.prototype.apply = function() {
        var t = this.renderContext, e = t.gl;
        e.useProgram(this.glProgram);
        for (var r = t.numActiveAttribArray; r < this.numActiveAttribArray; r++) e.enableVertexAttribArray(r);
        for (var r = this.numActiveAttribArray; r < t.numActiveAttribArray; r++) e.disableVertexAttribArray(r);
        t.numActiveAttribArray = this.numActiveAttribArray;
    }, k.prototype.dispose = function() {
        this.renderContext.gl.deleteProgram(this.glProgram);
    };
    var U = function(t, e) {
        this.parent = t, this.renderContext = this.parent.renderContext, this.tilePool = t.tilePool || new D(this.renderContext), 
        this.tiling = new L(4, 2), this.imageryProvider = null, this.elevationProvider = null, 
        this.tilesToRender = [], this.visibleTiles = [], this.tilesToRequest = [], this.postRenderers = [];
        var r = this.renderContext.gl;
        this.defaultTexture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.defaultTexture);
        var i = e.defaultColor ? e.defaultColor : [ 200, 200, 200, 255 ], n = new Uint8Array(i);
        r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, n), this.maxRequests = 4, 
        this.availableRequests = [];
        for (var o = 0; o < this.maxRequests; o++) this.availableRequests[o] = new O(this);
        this.pendingRequests = [], this.completedRequests = [], this.level0TilesLoaded = !1, 
        this.tileConfig = {
            tesselation: 9,
            skirt: !0,
            cullSign: 1,
            imageSize: 256,
            vertexSize: this.renderContext.lighting ? 6 : 3,
            normals: this.renderContext.lighting,
            coordinateSystem: this.parent.coordinateSystem
        }, this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool), 
        this.tcoordBuffer = null, this.tileIndexBuffer = new N(this.renderContext, this.tileConfig), 
        this.renderTileWithoutTexture = !e.hasOwnProperty("renderTileWithoutTexture") || e.renderTileWithoutTexture, 
        this.freeze = !1, this.numTilesGenerated = 0, this.frameNumber = 0, this.vertexShader = "\tattribute vec3 vertex;\n\tattribute vec2 tcoord;\n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec2 texCoord;\n", 
        this.renderContext.lighting && (this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n"), 
        this.vertexShader += "\tvoid main(void) \n\t{\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n", 
        this.renderContext.lighting && (this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n"), 
        this.vertexShader += "\t\ttexCoord = tcoord;\n\t}\n\t", this.fragmentShader = "\tprecision lowp float; \n\tvarying vec2 texCoord;\n", 
        this.renderContext.lighting && (this.fragmentShader += "varying vec3 color;\n"), 
        this.fragmentShader += "\tuniform sampler2D colorTexture;\n\tvoid main(void)\n\t{\n\t\tgl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n", 
        this.renderContext.lighting && (this.fragmentShader += "gl_FragColor.rgb *= color;\n"), 
        this.fragmentShader += "\t\tgl_FragColor.a = 1.0;\n\t}\n\t", this.program = new k(this.renderContext), 
        this.program.createFromSource(this.vertexShader, this.fragmentShader);
    };
    U.prototype.addPostRenderer = function(t) {
        this.postRenderers.push(t), this.postRenderers.sort(function(t, e) {
            var r = 0 | t.zIndex, i = 0 | e.zIndex;
            return r - i;
        }), t.generate && this.visitTiles(function(e) {
            t.generate(e);
        });
    }, U.prototype.removePostRenderer = function(t) {
        var e = this.postRenderers.indexOf(t);
        e != -1 && (t.cleanupTile && this.visitTiles(function(e) {
            t.cleanupTile(e);
        }), this.postRenderers.splice(e, 1));
    }, U.prototype.setImageryProvider = function(t) {
        this.reset(), this.imageryProvider = t, t && (this.tilePool.disposeAll(), this.tiling = t.tiling, 
        this.tileConfig.imageSize = t.tilePixelSize, this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool), 
        t.customShader ? (this.program.dispose(), this.program = new k(this.renderContext), 
        this.currentFragmentShader = t.customShader.fragmentCode ? t.customShader.fragmentCode : this.fragmentShader, 
        this.program.createFromSource(t.customShader.vertexCode ? t.customShader.vertexCode : this.vertexShader, this.currentFragmentShader)) : null != this.currentFragmentShader && (this.program.dispose(), 
        this.program = new k(this.renderContext), this.program.createFromSource(this.vertexShader, this.fragmentShader), 
        this.currentFragmentShader = null));
    }, U.prototype.setElevationProvider = function(t) {
        this.reset(), this.elevationProvider = t;
        var e = t ? t.tilePixelSize : 9;
        if (e != this.tileConfig.tesselation) {
            this.tileConfig.tesselation = e;
            var r = this.renderContext.gl;
            this.tileIndexBuffer.reset(), r.deleteBuffer(this.tcoordBuffer), this.tcoordBuffer = null;
        }
    }, U.prototype.reset = function() {
        this.abortRequests();
        for (var t = 0; t < this.level0Tiles.length; t++) this.level0Tiles[t].deleteChildren(this.renderContext, this.tilePool), 
        this.level0Tiles[t].dispose(this.renderContext, this.tilePool);
        this.level0TilesLoaded = !1;
    }, U.prototype.abortRequests = function() {
        for (var t = this.pendingRequests.length - 1; t >= 0; t--) this.pendingRequests[t].abort();
    }, U.prototype.visitTiles = function(t) {
        for (var e = this.level0Tiles.concat([]); e.length > 0; ) {
            var r = e.shift();
            t(r), r.children && (e.push(r.children[0]), e.push(r.children[1]), e.push(r.children[2]), 
            e.push(r.children[3]));
        }
    }, U.prototype.traverseTiles = function() {
        if (this.tilesToRender.length = 0, this.visibleTiles.length = 0, this.tilesToRequest.length = 0, 
        this.numTraversedTiles = 0, !this.level0TilesLoaded) {
            this.level0TilesLoaded = !0;
            for (var t = 0; t < this.level0Tiles.length; t++) {
                var e = this.level0Tiles[t], r = e.state == p.State.LOADED;
                e.frameNumber = this.frameNumber, this.level0TilesLoaded = this.level0TilesLoaded && r, 
                r || (e.state == p.State.NONE ? (e.state = p.State.REQUESTED, this.tilesToRequest.push(e)) : e.state == p.State.ERROR && this.imageryProvider && this.parent.publish("baseLayersError", this.imageryProvider));
            }
            this.level0TilesLoaded && this.imageryProvider && this.parent.publish("baseLayersReady");
        }
        if (this.level0TilesLoaded) for (var t = 0; t < this.level0Tiles.length; t++) {
            var e = this.level0Tiles[t];
            e.isCulled(this.renderContext) ? e.deleteChildren(this.renderContext, this.tilePool) : this.processTile(e, 0);
        }
    }, U.prototype.processTile = function(t, e) {
        this.numTraversedTiles++, t.frameNumber = this.frameNumber;
        var r = !0;
        if (t.state == p.State.NONE && (t.state = p.State.REQUESTED, this.tilesToRequest.push(t)), 
        t.state == p.State.LOADED && (r = !!this.imageryProvider && e >= this.imageryProvider.numberOfLevels, 
        r |= !t.needsToBeRefined(this.renderContext)), r) (t.texture || this.renderTileWithoutTexture) && this.tilesToRender.push(t), 
        this.visibleTiles.push(t); else {
            null == t.children && t.createChildren();
            for (var i = 0; i < 4; i++) t.children[i].isCulled(this.renderContext) ? t.children[i].deleteChildren(this.renderContext, this.tilePool) : this.processTile(t.children[i], e + 1);
        }
        for (var n in t.extension) {
            var o = t.extension[n];
            o.traverse && o.traverse(t, r);
        }
    }, U.prototype.generateTile = function(t, e) {
        t.generate(this.tilePool, e.image, e.elevations);
        for (var r = 0; r < this.postRenderers.length; r++) this.postRenderers[r].generate && this.postRenderers[r].generate(t);
        this.numTilesGenerated++, this.renderContext.requestFrame();
    }, U.prototype.generateReceivedTiles = function() {
        for (;this.completedRequests.length > 0; ) {
            var t = this.completedRequests.pop(), e = t.tile;
            e.frameNumber == this.frameNumber ? this.generateTile(e, t) : e.state = p.State.NONE, 
            this.availableRequests.push(t);
        }
        this.availableRequests.length == this.maxRequests && this.imageryProvider && this.parent.publish("endBackgroundLoad");
    }, U.prototype.renderTiles = function() {
        var t, e, r = this.renderContext, i = r.gl;
        if (this.tileConfig.cullSign < 0) t = .2 * this.tileConfig.coordinateSystem.radius, 
        e = 1.1 * this.tileConfig.coordinateSystem.radius; else {
            t = 1e9, e = 0;
            for (var n = 0; n < this.visibleTiles.length; n++) {
                var o = this.visibleTiles[n];
                t = Math.min(t, o.distance - 1.5 * o.radius), e = Math.max(e, o.distance + 1.5 * o.radius);
            }
        }
        if (r.near = Math.max(r.minNear, t), r.far = Math.max(r.minFar, e), 0 != this.tilesToRender.length) {
            this.tileConfig.cullSign < 0 ? (i.depthMask(!1), i.disable(i.DEPTH_TEST), i.disable(i.CULL_FACE)) : (i.enable(i.POLYGON_OFFSET_FILL), 
            i.polygonOffset(0, 4)), this.currentFragmentShader && this.currentFragmentShader != this.imageryProvider.customShader.fragmentCode && (this.program.dispose(), 
            this.program = new k(this.renderContext), this.imageryProvider && this.imageryProvider.customShader && (this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader, 
            this.program.createFromSource(this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader, this.currentFragmentShader))), 
            this.program.apply();
            var s = this.program.attributes;
            h.perspective(r.fov, r.canvas.width / r.canvas.height, r.near, r.far, r.projectionMatrix), 
            this.imageryProvider && this.imageryProvider.customShader && this.imageryProvider.customShader.updateUniforms(i, this.program), 
            i.activeTexture(i.TEXTURE0), i.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, r.projectionMatrix), 
            i.uniform1i(this.program.uniforms.colorTexture, 0), this.tcoordBuffer || this.buildSharedTexCoordBuffer(), 
            i.bindBuffer(i.ARRAY_BUFFER, this.tcoordBuffer), i.vertexAttribPointer(s.tcoord, 2, i.FLOAT, !1, 0, 0);
            for (var a = null, n = 0; n < this.tilesToRender.length; n++) {
                var o = this.tilesToRender[n], l = o.state == p.State.LOADED, u = o.parentIndex == -1;
                o.texture ? i.bindTexture(i.TEXTURE_2D, o.texture) : i.bindTexture(i.TEXTURE_2D, this.defaultTexture), 
                h.multiply(r.viewMatrix, o.matrix, r.modelViewMatrix), i.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, r.modelViewMatrix), 
                i.bindBuffer(i.ARRAY_BUFFER, o.vertexBuffer), i.vertexAttribPointer(s.vertex, 3, i.FLOAT, !1, 4 * this.tileConfig.vertexSize, 0), 
                this.tileConfig.normals && i.vertexAttribPointer(s.normal, 3, i.FLOAT, !1, 4 * this.tileConfig.vertexSize, 12);
                var c = l || u ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(o.parentIndex);
                a != c && (i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, c), a = c), i.drawElements(i.TRIANGLES, a.numIndices, i.UNSIGNED_SHORT, 0);
            }
            this.tileConfig.cullSign < 0 ? (i.depthMask(!0), i.enable(i.DEPTH_TEST)) : i.disable(i.POLYGON_OFFSET_FILL);
        }
        for (var n = 0; n < this.postRenderers.length; n++) this.postRenderers[n].render(this.visibleTiles);
    };
    var q = function(t, e) {
        return t.distance - e.distance;
    };
    U.prototype.launchRequests = function() {
        this.tilesToRequest.sort(q);
        for (var t = this.tilesToRequest.length, e = 0; e < t; e++) {
            var r = this.tilesToRequest[e];
            if (this.availableRequests.length > 0) {
                this.availableRequests.length == this.maxRequests && this.imageryProvider && this.parent.publish("startBackgroundLoad");
                var i = this.availableRequests.pop();
                i.launch(r);
            } else r.state = p.State.NONE;
        }
    }, U.prototype.render = function() {
        if (!this.imageryProvider || this.imageryProvider._ready) {
            if (!this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage) {
                this.imageryProvider.generateLevel0Textures(this.level0Tiles, this.tilePool);
                for (var t = 0; t < this.level0Tiles.length; t++) {
                    var e = this.level0Tiles[t];
                    this.generateTile(e, {});
                }
                this.level0TilesLoaded = !0, this.parent.publish("baseLayersReady");
            }
            var r = this.renderContext.stats;
            this.freeze || (r && r.start("traverseTime"), this.traverseTiles(), r && r.end("traverseTime")), 
            !this.level0TilesLoaded && this.imageryProvider || (r && r.start("renderTime"), 
            this.renderTiles(), r && r.end("renderTime")), r && r.start("generateTime"), this.generateReceivedTiles(), 
            r && r.end("generateTime"), r && r.start("requestTime"), this.launchRequests(), 
            r && r.end("requestTime"), this.frameNumber++;
        }
    }, U.prototype.getVisibleTile = function(t, e) {
        return this.tiling.findInsideTile(t, e, this.visibleTiles);
    }, U.prototype.buildSharedTexCoordBuffer = function() {
        var t = this.tileConfig.tesselation, e = this.tileConfig.skirt, r = 2 * t * t;
        e && (r += 2 * t * 6);
        for (var i = new Float32Array(r), n = 1 / (t - 1), o = 0, s = 0, a = 0; a < t; a++) {
            for (var h = 0, l = 0; l < t; l++) i[o] = h, i[o + 1] = s, o += 2, h += n;
            s += n;
        }
        if (e) {
            h = 0, s = 0;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, h += n, o += 2;
            h = 0, s = 1;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, h += n, o += 2;
            h = 0, s = 0;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, s += n, o += 2;
            h = 1, s = 0;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, s += n, o += 2;
            h = 0, s = .5;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, h += n, o += 2;
            h = .5, s = 0;
            for (var l = 0; l < t; l++) i[o] = h, i[o + 1] = s, s += n, o += 2;
        }
        var u = this.renderContext.gl, c = u.createBuffer();
        u.bindBuffer(u.ARRAY_BUFFER, c), u.bufferData(u.ARRAY_BUFFER, i, u.STATIC_DRAW), 
        this.tcoordBuffer = c;
    };
    var z = function(t) {
        this.renderers = [];
        for (var e = 0; e < z.factory.length; e++) this.renderers.push(z.factory[e](t));
        this.renderables = [], this.bucketId = 0;
    };
    z.factory = [], z.prototype.getRenderer = function(t, e) {
        for (var r = 0; r < this.renderers.length; r++) if (this.renderers[r].canApply(t.type, e)) return this.renderers[r];
        return null;
    }, z.prototype.generate = function(t) {
        if (t.parent) {
            var e = t.parent.extension.renderer;
            if (e) {
                delete t.extension.renderer;
                for (var r = 0; r < e.renderables.length; r++) {
                    var i = e.renderables[r];
                    i.generateChild && i.generateChild(t);
                }
            }
        } else for (var r = 0; r < this.renderers.length; r++) this.renderers[r].generateLevelZero(t);
    }, z.prototype.addGeometry = function(t, e, r) {
        var i = this.getRenderer(e, r);
        i.addGeometry(t, e, r);
    }, z.prototype.removeGeometry = function(t, e) {
        var r = t._bucket;
        return !(!r || r.layer != e) && (r.renderer.removeGeometry(t), !0);
    }, z.prototype.addGeometryToTile = function(t, e, r, i) {
        var n = this.getRenderer(e, r);
        n.addGeometryToTile(t, e, r, i);
    }, z.prototype.removeGeometryFromTile = function(t, e) {
        var r = t._bucket;
        r.renderer.removeGeometryFromTile(t, e);
    };
    var V = function(t, e) {
        var r = t.bucket.style.zIndex - e.bucket.style.zIndex;
        return 0 == r ? t.bucket.id - e.bucket.id : r;
    };
    z.prototype.render = function() {
        for (var t = 0; t < this.renderers.length; t++) for (var e = this.renderers[t].buckets, r = 0; r < e.length; r++) e[r].layer._visible && e[r].mainRenderable && this.renderables.push(e[r].mainRenderable);
        this.renderables.sort(V);
        for (var r = 0; r < this.renderables.length; ) {
            for (var t = r + 1, i = this.renderables[r].bucket.renderer; t < this.renderables.length && this.renderables[t].bucket.renderer == i; ) t++;
            i.render(this.renderables, r, t), r = t;
        }
        this.renderables.length = 0;
    };
    var G = function(t, e) {
        this.orig = t, this.dir = e;
    };
    G.createFromPixel = function(t, e, r) {
        var i = e / t.canvas.width * 2 - 1, n = -(r / t.canvas.height * 2 - 1), o = h.create();
        h.multiply(t.projectionMatrix, t.viewMatrix, o), h.inverse(o);
        var a = h.multiplyVec4(o, [ i, n, -1, 1 ]);
        a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
        var l = h.create();
        h.inverse(t.viewMatrix, l), s.set([ 0, 0, 0 ], t.eyePosition), h.multiplyVec3(l, t.eyePosition);
        var u = s.create(t.eyePosition), c = s.subtract(a, t.eyePosition, s.create());
        return s.normalize(c), new G(u, c);
    }, G.createFromEvent = function(t, e) {
        var r = t.getXYRelativeToCanvas(e);
        return G.createFromPixel(r[0], r[1]);
    }, G.Intersection = function(t) {
        this.t = t, this.geometry = null;
    }, G.prototype.computePoint = function(t) {
        var e = s.create();
        return s.scale(this.dir, t, e), s.add(e, this.orig), e;
    }, G.prototype.planeIntersect = function(t, e) {
        var r = s.dot(e, this.dir), i = 1e-6;
        if (Math.abs(r) > i) {
            var n = s.create();
            s.subtract(t, this.orig, n);
            var o = s.dot(n, e) / r;
            return o;
        }
        return -1;
    }, G.prototype.sphereIntersect = function(t, e) {
        var r = s.subtract(this.orig, t, s.create()), i = 2 * s.dot(this.dir, r), n = s.dot(r, r) - e * e, o = i * i - 4 * n;
        if (o < 0) return -1;
        o = Math.sqrt(o);
        var a = (-i - o) / 2, h = (-i + o) / 2;
        if (a > h) {
            var l = a;
            a = h, h = l;
        }
        return h < 0 ? -1 : a < 0 ? h : a;
    };
    var W = 1e-6;
    G.prototype.triangleIntersectOptimized = function(t, e, r, i) {
        var n = t[r] - t[e], o = t[r + 1] - t[e + 1], s = t[r + 2] - t[e + 2], a = t[i] - t[e], h = t[i + 1] - t[e + 1], l = t[i + 2] - t[e + 2], u = this.dir[1] * l - this.dir[2] * h, c = this.dir[2] * a - this.dir[0] * l, d = this.dir[0] * h - this.dir[1] * a, f = n * u + o * c + s * d;
        if (f > -W && f < W) return null;
        var p = 1 / f, m = this.orig[0] - t[e], v = this.orig[1] - t[e + 1], g = this.orig[2] - t[e + 2], y = (m * u + v * c + g * d) * p;
        if (y < 0 || y > 1) return null;
        var x = v * s - g * o, b = g * n - m * s, T = m * o - v * n, _ = (this.dir[0] * x + this.dir[1] * b + this.dir[2] * T) * p;
        if (_ < 0 || y + _ > 1) return null;
        var M = (a * x + h * b + l * T) * p;
        return M >= 0 ? new G.Intersection(M) : null;
    };
    var X = function() {
        this.callbacks = {};
    };
    X.prototype.subscribe = function(t, e) {
        this.callbacks[t] ? this.callbacks[t].push(e) : this.callbacks[t] = [ e ];
    }, X.prototype.unsubscribe = function(t, e) {
        if (this.callbacks[t]) {
            var r = this.callbacks[t].indexOf(e);
            r != -1 && this.callbacks[t].splice(r, 1);
        }
    }, X.prototype.publish = function(t, e) {
        if (this.callbacks[t]) for (var r = this.callbacks[t], i = 0; i < r.length; i++) r[i](e);
    };
    var Y = function(t) {
        X.prototype.constructor.call(this), t.coordinateSystem ? this.coordinateSystem = t.coordinateSystem : this.coordinateSystem = new r(), 
        t.renderContext ? this.renderContext = t.renderContext : this.renderContext = new d(t), 
        this.tileManager = new U(this, t), this.vectorRendererManager = new z(this), this.attributionHandler = null, 
        this.baseImagery = null, this.preRenderers = [], this.nbCreatedLayers = 0, this.tileManager.addPostRenderer(this.vectorRendererManager), 
        this.renderContext.renderers.push(this), this.renderContext.requestFrame();
    };
    m.inherits(X, Y), Y.prototype.dispose = function() {
        this.tileManager.tilePool.disposeAll(), this.tileManager.reset();
    }, Y.prototype.destroy = function() {
        this.dispose(), this.tileManager.removePostRenderer(this.vectorRendererManager), 
        this.renderContext.renderers.splice(this.renderContext.renderers.indexOf(this.globe), 1);
    }, Y.prototype.refresh = function() {
        this.renderContext.requestFrame();
    }, Y.prototype.setBaseImagery = function(t) {
        this.baseImagery != t && (this.baseImagery && (this.removeLayer(this.baseImagery), 
        this.baseImagery = null), t && (t._overlay = !1, this.addLayer(t), this.baseImagery = t), 
        this.tileManager.setImageryProvider(t));
    }, Y.prototype.setBaseElevation = function(t) {
        this.tileManager.elevationProvider && this.removeLayer(this.tileManager.elevationProvider), 
        this.tileManager.setElevationProvider(t), t && (t._overlay = !1, this.addLayer(t));
    }, Y.prototype.addLayer = function(t) {
        t.id = this.nbCreatedLayers, t._attach(this), this.renderContext.requestFrame(), 
        this.nbCreatedLayers++;
    }, Y.prototype.removeLayer = function(t) {
        t._detach(), this.renderContext.requestFrame();
    }, Y.prototype.addAnimation = function(t) {
        t.renderContext = this.renderContext;
    }, Y.prototype.removeAnimation = function(t) {
        t.renderContext = null;
    }, Y.prototype.getElevation = function(t, e) {
        var r = this.tileManager.tiling;
        if (this.baseImagery) var r = this.baseImagery.tiling;
        var i = this.tileManager.level0Tiles[r.lonlat2LevelZeroIndex(t, e)];
        return i.state == p.State.LOADED ? i.getElevation(t, e) : 0;
    }, Y.prototype.getViewportGeoBound = function(t) {
        var e = this.renderContext, r = h.create();
        h.inverse(e.viewMatrix, r);
        var i = [ r[12], r[13], r[14] ];
        h.multiply(e.projectionMatrix, e.viewMatrix, r), h.inverse(r);
        for (var n = [ [ -1, -1, 1, 1 ], [ 1, -1, 1, 1 ], [ -1, 1, 1, 1 ], [ 1, 1, 1, 1 ] ], o = [ 0, 0, 0 ], a = 0; a < 4; a++) {
            h.multiplyVec4(r, n[a]), s.scale(n[a], 1 / n[a][3]), s.subtract(n[a], i, n[a]), 
            s.normalize(n[a]);
            var l = new G(i, n[a]), u = l.sphereIntersect(o, this.coordinateSystem.radius);
            if (u < 0) return null;
            var c = l.computePoint(u);
            n[a] = this.coordinateSystem.from3DToGeo(c), t && (n[a] = t(n[a]));
        }
        var d = new v();
        return d.computeFromCoordinates(n), d;
    }, Y.prototype.getLonLatFromPixel = function(t, e) {
        var r, i = G.createFromPixel(this.renderContext, t, e);
        return r = this.coordinateSystem.isFlat ? i.planeIntersect([ 0, 0, 0 ], [ 0, 0, 1 ]) : i.sphereIntersect([ 0, 0, 0 ], this.coordinateSystem.radius), 
        r >= 0 ? this.coordinateSystem.from3DToGeo(i.computePoint(r)) : null;
    }, Y.prototype.getPixelFromLonLat = function(t, e) {
        var r = s.create();
        this.coordinateSystem.fromGeoTo3D([ t, e ], r);
        var i = this.renderContext.getPixelFrom3D(r[0], r[1], r[2]);
        return i;
    }, Y.prototype.render = function() {
        for (var t = 0; t < this.preRenderers.length; t++) this.preRenderers[t].preRender();
        this.tileManager.render();
    }, Y.prototype.setCoordinateSystem = function(t) {
        this.coordinateSystem = t, this.tileManager.tileConfig.coordinateSystem = t, this.dispose(), 
        this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(this.tileManager.tileConfig, this.tileManager.tilePool);
    }, Y.prototype.getRenderStats = function() {
        return "# rendered tiles : " + this.tileManager.tilesToRender.length;
    };
    var H = function(t) {
        r.prototype.constructor.call(this, t), this.isFlat = !0;
    };
    m.inherits(r, H);
    var j = function(t) {
        return t ? t / Math.sin(t) : 1;
    };
    H.prototype.from3DToGeo = function(t, e) {
        e || (e = Array(3));
        var r = .005;
        if (!(t[0] * t[0] + 4 * t[1] * t[1] > Math.PI * Math.PI + r)) {
            var i = t[0], n = t[1], o = 25;
            do {
                var s, a = Math.sin(i), h = Math.sin(i / 2), l = Math.cos(i / 2), u = Math.sin(n), c = Math.cos(n), d = Math.sin(2 * n), f = u * u, p = c * c, m = h * h, v = 1 - p * l * l, g = v ? Math.acos(c * l) * Math.sqrt(s = 1 / v) : s = 0, y = 2 * g * c * h - t[0], x = g * u - t[1], b = s * (p * m + g * c * l * f), T = s * (.5 * a * d - 2 * g * u * h), _ = .25 * s * (d * h - g * u * p * a), M = s * (f * l + g * m * c), R = T * _ - M * b;
                if (!R) break;
                var S = (x * T - y * M) / R, w = (y * _ - x * b) / R;
                i -= S, n -= w;
            } while ((Math.abs(S) > r || Math.abs(w) > r) && --o > 0);
            return e[0] = 180 * i / Math.PI, e[1] = 180 * n / Math.PI, e[2] = 0, e;
        }
    }, H.prototype.fromGeoTo3D = function(t, e) {
        e || (e = Array(3));
        var r = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, n = Math.cos(i), o = j(Math.acos(n * Math.cos(r /= 2)));
        return e[0] = 2 * n * Math.sin(r) * o, e[1] = Math.sin(i) * o, e[2] = 0, e;
    };
    var Z = function(t) {
        r.prototype.constructor.call(this, t), this.isFlat = !0;
    };
    m.inherits(r, Z), Z.prototype.from3DToGeo = function(t, e) {}, Z.prototype.fromGeoTo3D = function(t, e) {
        e || (e = Array(3));
        var r = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, n = Math.tan(i / 2), o = Math.sqrt(1 - n * n), s = 1 + o * Math.cos(r /= 2), a = Math.sin(r) * o / s, h = n / s, l = a * a, u = h * h;
        return e[0] = 4 / 3 * a * (3 + l - 3 * u), e[1] = 4 / 3 * h * (3 + 3 * l - u), e[2] = 0, 
        e;
    };
    var Q = function(t) {
        r.prototype.constructor.call(this, t), this.isFlat = !0, this.lambda0 = t && t.lambda0 ? t.lambda0 : 0;
    };
    m.inherits(r, Q);
    var K = function(t) {
        var e = Math.exp(t);
        return (e - 1 / e) / 2;
    };
    Q.prototype.from3DToGeo = function(t, e) {
        return e || (e = Array(3)), e[0] = this.lambda0 + 180 * t[0] / Math.PI, e[1] = 180 * Math.atan(K(t[1])) / Math.PI, 
        e[2] = 0, e;
    }, Q.prototype.fromGeoTo3D = function(t, e) {
        e || (e = Array(3)), t[1] > 85.05 && (t[1] = 85.05), t[1] < -85.05 && (t[1] = -85.05);
        var r = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, n = r - this.lambda0 * Math.PI / 180, o = Math.log(Math.tan(i) + 1 / Math.cos(i));
        return e[0] = n, e[1] = o, e[2] = 0, e;
    };
    var $ = function(t) {
        r.prototype.constructor.call(this, t), this.isFlat = !0;
    };
    m.inherits(r, $), $.prototype.from3DToGeo = function(t, e) {
        e || (e = Array(3));
        var r = Math.asin(t[1] / Math.sqrt(2)), i = Math.asin((2 * r + Math.sin(2 * r)) / Math.PI), n = Math.PI * t[0] / (2 * Math.sqrt(2) * Math.cos(r));
        return e[0] = 180 * n / Math.PI, e[1] = 180 * i / Math.PI, e[2] = 0, e;
    }, $.prototype.fromGeoTo3D = function(e, r) {
        r || (r = Array(3));
        var i = e[0] * Math.PI / 180, n = e[1] * Math.PI / 180, o = t(n), s = 2 * Math.sqrt(2) / Math.PI * i * Math.cos(o), a = Math.sqrt(2) * Math.sin(o);
        return r[0] = s, r[1] = a, r[2] = 0, r;
    };
    var J = function(t) {
        r.prototype.constructor.call(this, t), this.isFlat = !0;
    };
    m.inherits(r, J), J.prototype.from3DToGeo = function(t, e) {
        return e || (e = Array(3)), e[0] = 180 * t[0] / Math.PI, e[1] = 180 * t[1] / Math.PI, 
        e[2] = 0, e;
    }, J.prototype.fromGeoTo3D = function(t, e) {
        return e || (e = Array(3)), e[0] = t[0] * Math.PI / 180, e[1] = t[1] * Math.PI / 180, 
        e[2] = 0, e;
    };
    var tt = function() {
        this.getCapabilities = getCapabilities();
    };
    tt.createAitoff = function(t) {
        return layer = new H(t), layer;
    }, tt.createAugust = function(t) {
        return layer = new Z(t), layer;
    }, tt.createMercator = function() {
        return layer = new Q(), layer;
    }, tt.createMollweide = function(t) {
        return layer = new $(t), layer;
    }, tt.createPlate = function(t) {
        return layer = new J(t), layer;
    }, tt.getCapabilities = function() {
        capabilities = [ {
            method: "createAitoff",
            parameters: []
        }, {
            method: "createAugust",
            parameters: []
        }, {
            method: "createMercator",
            parameters: [ {
                mandatory: "no",
                name: "lambda0",
                type: "Float",
                desc: "TODO"
            } ]
        }, {
            method: "createMollweide",
            parameters: []
        }, {
            method: "createPlate",
            parameters: []
        } ];
    };
    var et = function(t) {
        var e = null, r = -1, i = -1, n = -1, o = 0, s = 0, a = t && t.panButton || 0, h = t && t.rotateButton || 1, l = function(t) {
            var r;
            return r = void 0 === t.wheelDelta ? t.detail : -t.wheelDelta / 120, e.zoom(r), 
            e.stopAnimations(), e.inertia && e.inertia.launch("zoom", r < 0 ? -1 : 1), t.preventDefault && t.preventDefault(), 
            t.returnValue = !1, !1;
        }, u = function(t) {
            return document.addEventListener("mouseup", c), r = t.button, e.stopAnimations(), 
            t.button != a && t.button != h || (i = t.clientX, n = t.clientY, o = 0, s = 0, !1);
        }, c = function(t) {
            return r = -1, document.removeEventListener("mouseup", c), !e.inertia || 0 == o && 0 == s || (t.button == a && e.inertia.launch("pan", o, s), 
            t.button == h && e.inertia.launch("rotate", o, s)), t.button != a && t.button != h || (t.preventDefault(), 
            !1);
        }, d = function(t) {
            if (!(r < 0) && (o = t.clientX - i, s = t.clientY - n, 0 != o || 0 != s)) {
                var l = !1;
                return r == a ? (e.pan(o, s), l = !0) : r == h && (e.rotate(o, s), l = !0), i = t.clientX, 
                n = t.clientY, l;
            }
        }, f = function(t) {
            if (0 == t.button) {
                var r = e.globe.renderContext.getXYRelativeToCanvas(t), i = e.globe.getLonLatFromPixel(r[0], r[1]);
                i && e.zoomTo(i);
            }
        };
        this.install = function(r) {
            e = r;
            var i = e.renderContext.canvas;
            i.addEventListener("mousedown", u), i.addEventListener("mousemove", d), t && t.zoomOnDblClick && i.addEventListener("dblclick", f), 
            i.addEventListener("DOMMouseScroll", l), i.addEventListener("mousewheel", l), i.addEventListener("dragstart", function(t) {
                return t.preventDefault(), !1;
            }), 2 == h && i.addEventListener("contextmenu", function(t) {
                return t.preventDefault(), !1;
            }, !1);
        }, this.uninstall = function() {
            var r = e.renderContext.canvas;
            r.removeEventListener("mousedown", u), r.removeEventListener("mousemove", d), t && t.zoomOnDblClick && r.removeEventListener("dblclick", f), 
            r.removeEventListener("DOMMouseScroll", l), r.removeEventListener("mousewheel", l);
        };
    }, rt = function(t) {
        var e = null, r = this;
        this.panFactor = 10, this.zoomFactor = 1, t && (t.panFactor && "number" == typeof t.panFactor && (this.panFactor = t.panFactor), 
        t.zoomFactor && "number" == typeof t.zoomFactor && (this.zoomFactor = t.zoomFactor));
        var i = function(t) {
            return this.focus(), !1;
        }, n = function(t) {
            switch (t.keyCode) {
              case 32:
                e.stopAnimations();
                break;

              case 187:
              case 61:
              case 107:
                e.zoom(-r.zoomFactor);
                break;

              case 189:
              case 54:
              case 109:
                e.zoom(r.zoomFactor);
                break;

              case 81:
              case 37:
                t.shiftKey ? e.rotate(r.panFactor, 0) : e.pan(r.panFactor, 0);
                break;

              case 90:
              case 38:
                t.shiftKey ? e.rotate(0, r.panFactor) : e.pan(0, r.panFactor);
                break;

              case 68:
              case 39:
                t.shiftKey ? e.rotate(-r.panFactor, 0) : e.pan(-r.panFactor, 0);
                break;

              case 83:
              case 40:
                t.shiftKey ? e.rotate(0, -r.panFactor) : e.pan(0, -r.panFactor);
            }
        };
        this.install = function(r) {
            if (e = r, t && t.installOnDocument) document.addEventListener("keydown", n); else {
                var o = e.renderContext.canvas;
                o.addEventListener("keydown", n), o.tabIndex = "0", o.addEventListener("mousedown", i);
            }
        }, this.uninstall = function() {
            if (t && t.installOnDocument) document.removeEventListener("keydown", n); else {
                var r = e.renderContext.canvas;
                r.removeEventListener("keydown", n), r.removeEventListener("mousedown", i);
            }
        };
    }, it = {
        PAN: 0,
        ROTATE: 1,
        TILT: 2,
        ZOOM: 3
    }, nt = function(t) {
        var e, r, i, n, o, s, a, h = null, l = [], u = [ 0, 0, 0, 0 ], c = 300, d = !(!t || !t.hasOwnProperty("inversed")) && t.inversed, f = function(t, e) {
            var r = e.clientY - t.clientY, i = e.clientX - t.clientX;
            return 180 * Math.atan2(r, i) / Math.PI;
        }, p = function(t, e) {
            return t.length >= 2 && e.length >= 2 ? f(e[1], e[0]) - f(t[1], t[0]) : 0;
        }, m = function(t) {
            if (r = t.touches, l = t.touches, u = [ 0, 0, 0, 0 ], h.stopAnimations(), n = 0, 
            o = 0, 2 == t.touches.length) {
                var s = t.touches[0].clientX - t.touches[1].clientX, a = t.touches[0].clientY - t.touches[1].clientY;
                e = Math.sqrt(s * s + a * a), console.log("Finger distance : " + e), i = p(l, t.touches);
            }
            return t.preventDefault && t.preventDefault(), t.returnValue = !1, !1;
        }, v = function(t) {
            if (n = t.touches[0].clientX - r[0].clientX, o = t.touches[0].clientY - r[0].clientY, 
            1 == t.touches.length) h.pan(n, o), u[it.PAN]++; else {
                var s = (t.touches[0].clientY - r[0].clientY) * (t.touches[1].clientY - r[1].clientY) > 0;
                if (s) h.rotate(0, -o), u[it.TILT]++; else {
                    var c = p(l, t.touches), f = c - i;
                    i = c, d && (f *= -1), a = 10 * f, h.rotate(a, 0), u[it.ROTATE]++;
                }
                var m, f = t.touches[0].clientX - t.touches[1].clientX, v = t.touches[0].clientY - t.touches[1].clientY, g = Math.sqrt(f * f + v * v), y = g - e;
                m = d ? g / e : e / g, 0 != e && (h.zoom(.025 * y, m), u[it.ZOOM]++), h.renderContext.requestFrame(), 
                e = g;
            }
            return r = t.touches, t.preventDefault && t.preventDefault(), t.returnValue = !1, 
            !1;
        }, g = function(e) {
            if (t && t.zoomOnDblClick && 0 == e.touches.length && 0 == n && 0 == o) {
                var i = Date.now();
                if (i - s < c) {
                    var a = h.globe.getLonLatFromPixel(r[0].clientX, r[0].clientY);
                    a && h.zoomTo(a);
                }
                s = i;
            }
            if (r = e.touches, h.inertia && (0 != n || 0 != o)) {
                var l = u.indexOf(Math.max.apply(this, u));
                l == it.PAN ? h.inertia.launch("pan", n, o) : l == it.ROTATE || l == it.TILT;
            }
            return e.preventDefault && e.preventDefault(), e.returnValue = !1, !1;
        };
        this.install = function(t) {
            h = t;
            var e = h.renderContext.canvas;
            e.addEventListener("touchstart", m, !1), e.addEventListener("touchend", g, !1), 
            e.addEventListener("touchmove", v, !1);
        }, this.uninstall = function() {
            var t = h.renderContext.canvas;
            t.removeEventListener("touchstart", m, !1), t.removeEventListener("touchend", g, !1), 
            t.removeEventListener("touchmove", v, !1);
        };
    }, ot = function() {
        this.startTime = -1, this.pauseTime = -1, this.renderContext = null;
    };
    ot.prototype._unregisterActive = function() {
        var t = this.renderContext.activeAnimations.indexOf(this);
        t >= 0 && this.renderContext.activeAnimations.splice(t, 1);
    }, ot.prototype.getStatus = function() {
        return this.startTime == -1 ? "STOPPED" : this.pauseTime == -1 ? "RUNNING" : "PAUSED";
    }, ot.prototype.start = function() {
        if (this.renderContext && (this.startTime == -1 || this.pauseTime != -1)) {
            var t = Date.now();
            this.startTime == -1 ? this.startTime = t : (this.startTime += t - this.pauseTime, 
            this.pauseTime = -1), this.renderContext.activeAnimations.push(this), this.renderContext.requestFrame();
        }
    }, ot.prototype.pause = function() {
        this.renderContext && this.startTime != -1 && this.pauseTime == -1 && (this.pauseTime = Date.now(), 
        this._unregisterActive(this));
    }, ot.prototype.stop = function() {
        this.startTime = -1, this.pauseTime = -1, this.onstop && this.onstop(), this._unregisterActive(this);
    };
    var st = .1, at = function(t, e) {
        ot.prototype.constructor.call(this), e && (this.panFactor = e.hasOwnProperty("panFactor") ? e.panFactor : .95, 
        this.rotateFactor = e.hasOwnProperty("rotateFactor") ? e.rotateFactor : .95, this.zoomFactor = e.hasOwnProperty("zoomFactor") ? e.zoomFactor : .95), 
        this.type = null, this.dx = 0, this.dy = 0, this.navigation = t, this.renderContext = t.renderContext;
    };
    m.inherits(ot, at), at.prototype.update = function(t) {
        var e = !1;
        switch (this.type) {
          case "pan":
            this.navigation.pan(this.dx, this.dy), this.dx *= this.panFactor, this.dy *= this.panFactor, 
            e = Math.abs(this.dx) < st && Math.abs(this.dy) < st;
            break;

          case "rotate":
            this.navigation.rotate(this.dx, this.dy), this.dx *= this.rotateFactor, this.dy *= this.rotateFactor, 
            e = Math.abs(this.dx) < st && Math.abs(this.dy) < st;
            break;

          case "zoom":
            this.navigation.zoom(this.dx), this.dx *= this.zoomFactor, e = Math.abs(this.dx) < st;
        }
        this.navigation.renderContext.requestFrame(), e && this.stop();
    }, at.prototype.launch = function(t, e, r) {
        this.type = t, this.dx = e, this.dy = r, this.start();
    };
    var ht = function(t, e) {
        ot.prototype.constructor.call(this), this.segments = [], this.duration = t, this.valueSetter = e;
    };
    m.inherits(ot, ht);
    var lt = function(t, e, r, i, n) {
        this.start = t, this.startValue = e, this.end = r, this.endValue = i, this.interpolator = n;
    };
    ht.prototype.addSegment = function(t, e, r, i, n) {
        for (var o = this.segments.length, s = 0; s < o && this.segments[s].end <= t; ) s++;
        this.segments.splice(s, 0, new lt(t, e, r, i, n));
    }, ht.prototype.update = function(t) {
        var r = e.map01(t, this.startTime, this.startTime + this.duration);
        if (r >= 1) {
            var i = this.segments.length - 1;
            this.valueSetter(this.segments[i].endValue), this.stop();
        } else {
            for (var n = this.segments.length, o = 0; o < n && this.segments[o].end < r; ) o++;
            o = Math.min(o, n - 1), r = e.map01(r, this.segments[o].start, this.segments[o].end);
            var s = this.segments[o].interpolator(r, this.segments[o].startValue, this.segments[o].endValue);
            this.valueSetter(s);
        }
    };
    var ut = function(t, e) {
        X.prototype.constructor.call(this), this.renderContext = t, e && e.handlers ? this.handlers = e.handlers : e && e.isMobile ? this.handlers = [ new nt(e ? e.touch : null) ] : this.handlers = [ new et(e ? e.mouse : null), new rt(e ? e.keyboard : null) ], 
        e && e.inertia && (this.inertia = new at(this, e)), this.zoomToAnimation = null, 
        this.start();
    };
    m.inherits(X, ut), ut.prototype.start = function() {
        for (var t = 0; t < this.handlers.length; t++) this.handlers[t].install(this);
    }, ut.prototype.stop = function() {
        for (var t = 0; t < this.handlers.length; t++) this.handlers[t].uninstall();
    }, ut.prototype.stopAnimations = function() {
        this.inertia && this.inertia.stop(), this.zoomToAnimation && (this.zoomToAnimation.stop(), 
        this.zoomToAnimation = null);
    }, ut.prototype.getFov = function() {
        var t = this.renderContext.canvas.width / this.renderContext.canvas.height;
        return [ t * this.renderContext.fov, this.renderContext.fov ];
    }, ut.prototype.toViewMatrix = function(t, r, i, n) {
        var o = this, a = this.renderContext.viewMatrix, u = h.toMat3(a), c = l.fromRotationMatrix(u), d = h.toMat3(t), f = l.fromRotationMatrix(d), p = r || 45;
        i = i || 1e3;
        var m = [ c, [ a[12], a[13], a[14] ], o.renderContext.fov ], v = [ f, [ t[12], t[13], t[14] ], p ], g = new ht(i, function(t) {
            var e = l.toMat4(t[0]);
            o.renderContext.viewMatrix = h.transpose(e), o.renderContext.viewMatrix[12] = t[1][0], 
            o.renderContext.viewMatrix[13] = t[1][1], o.renderContext.viewMatrix[14] = t[1][2], 
            o.renderContext.fov = t[2], o.renderContext.requestFrame();
        });
        g.addSegment(0, m, 1, v, function(t, r, i) {
            var n = e.easeOutQuad(t), o = l.create();
            l.slerp(r[0], i[0], n, o);
            var a = s.create();
            s.lerp(r[1], i[1], n, a);
            var h = e.lerp(n, r[2], i[2]);
            return [ o, a, h ];
        }), g.onstop = function() {
            n && n();
        }, this.globe.addAnimation(g), g.start();
    };
    var ct = function(t, e) {
        ut.prototype.constructor.call(this, t.renderContext, e), this.globe = t, this.minDistance = e && e.minDistance || 1, 
        this.maxDistance = e && e.maxDistance || 3 * this.globe.coordinateSystem.realEarthRadius, 
        this.geoCenter = [ 0, 0, 0 ], this.heading = 0, this.tilt = 90, this.distance = 3 * this.globe.coordinateSystem.radius, 
        this.minDistance *= this.globe.coordinateSystem.heightScale, this.maxDistance *= this.globe.coordinateSystem.heightScale, 
        this.inverseViewMatrix = h.create();
        var r = !e || !e.hasOwnProperty("updateViewMatrix") || e.updateViewMatrix;
        r && this.computeViewMatrix();
    };
    m.inherits(ut, ct), ct.prototype.save = function() {
        return {
            geoCenter: this.geoCenter,
            heading: this.heading,
            tilt: this.tilt,
            distance: this.distance
        };
    }, ct.prototype.restore = function(t) {
        this.geoCenter = t.geoCenter, this.heading = t.heading, this.tilt = t.tilt, this.distance = t.distance, 
        this.computeViewMatrix();
    }, ct.prototype.zoomTo = function(t, r, i, n, o) {
        var a = this, h = r || this.distance / (4 * this.globe.coordinateSystem.heightScale);
        i = i || 5e3;
        var l = n || 90, u = [ this.geoCenter[0], this.geoCenter[1], this.distance, this.tilt ], c = [ t[0], t[1], h * this.globe.coordinateSystem.heightScale, l ];
        this.zoomToAnimation = new ht(i, function(t) {
            a.geoCenter[0] = t[0], a.geoCenter[1] = t[1], a.distance = t[2], a.tilt = t[3], 
            a.computeViewMatrix();
        });
        var d = this.globe.coordinateSystem.fromGeoTo3D(this.geoCenter), f = this.globe.coordinateSystem.fromGeoTo3D(t), p = s.subtract(d, f), m = s.length(p), v = this.globe.renderContext.canvas, g = Math.min(e.toRadian(45), e.toRadian(45 * v.width / v.height)), y = 1.1 * (m / 2 / Math.tan(g / 2));
        if (y > this.distance) {
            var x = [ .5 * u[0] + .5 * c[0], .5 * u[1] + .5 * c[1], y, l ];
            this.zoomToAnimation.addSegment(0, u, .5, x, function(t, r, i) {
                var n = e.easeInQuad(t), o = e.easeOutQuad(t);
                return [ e.lerp(n, r[0], i[0]), e.lerp(n, r[1], i[1]), e.lerp(o, r[2], i[2]), e.lerp(t, r[3], i[3]) ];
            }), this.zoomToAnimation.addSegment(.5, x, 1, c, function(t, r, i) {
                var n = e.easeOutQuad(t), o = e.easeInQuad(t);
                return [ e.lerp(n, r[0], i[0]), e.lerp(n, r[1], i[1]), e.lerp(o, r[2], i[2]), e.lerp(t, r[3], i[3]) ];
            });
        } else this.zoomToAnimation.addSegment(0, u, 1, c, function(t, r, i) {
            var n = e.easeOutQuad(t), o = e.easeInQuad(t);
            return [ e.lerp(n, r[0], i[0]), e.lerp(n, r[1], i[1]), e.lerp(o, r[2], i[2]), e.lerp(t, r[3], i[3]) ];
        });
        var b = this;
        this.zoomToAnimation.onstop = function() {
            o && o(), b.zoomToAnimation = null;
        }, this.globe.addAnimation(this.zoomToAnimation), this.zoomToAnimation.start();
    }, ct.prototype.applyLocalRotation = function(t) {
        h.rotate(t, this.heading * Math.PI / 180, [ 0, 0, 1 ]), h.rotate(t, (90 - this.tilt) * Math.PI / 180, [ 1, 0, 0 ]);
    }, ct.prototype.computeViewMatrix = function() {
        this.computeInverseViewMatrix(), h.inverse(this.inverseViewMatrix, this.renderContext.viewMatrix), 
        this.publish("modified"), this.renderContext.requestFrame();
    }, ct.prototype.computeInverseViewMatrix = function() {
        this.globe.coordinateSystem.getLHVTransform(this.geoCenter, this.inverseViewMatrix), 
        this.applyLocalRotation(this.inverseViewMatrix), h.translate(this.inverseViewMatrix, [ 0, 0, this.distance ]);
    }, ct.prototype.zoom = function(t, e) {
        var r = this.distance;
        e ? this.distance *= e : this.distance *= 1 + .1 * t, this.distance > this.maxDistance && (this.distance = this.maxDistance), 
        this.distance < this.minDistance && (this.distance = this.minDistance), this.computeViewMatrix(), 
        this.hasCollision() && (this.distance = r, this.computeViewMatrix());
    }, ct.prototype.hasCollision = function() {
        var t = [ this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14] ], e = s.create();
        this.globe.coordinateSystem.from3DToGeo(t, e);
        var r = this.globe.getElevation(e[0], e[1]);
        return e[2] < r + 50;
    }, ct.prototype.pan = function(t, e) {
        var r = s.create();
        s.set(this.geoCenter, r);
        var i = h.create(), n = this.globe.coordinateSystem;
        n.getLocalTransform(this.geoCenter, i);
        var o = s.create(), a = s.create([ 0, 1, 0 ]);
        n.getUpVector(i, o), h.multiplyVec3(i, a, a), this.applyLocalRotation(i);
        var l = s.create(), u = s.create();
        n.getSideVector(i, l), n.getFrontVector(i, u), s.cross(o, l, u), s.cross(u, o, l), 
        s.normalize(l, l), s.normalize(u, u), t /= this.renderContext.canvas.width, e /= this.renderContext.canvas.height;
        var c = s.create();
        n.fromGeoTo3D(this.geoCenter, c), s.scale(l, t * this.distance, l), s.scale(u, e * this.distance, u), 
        s.subtract(c, l, c), s.add(c, u, c), s.normalize(c), s.scale(c, n.radius), n.from3DToGeo(c, this.geoCenter);
        var d = s.create([ 0, 1, 0 ]);
        n.getLocalTransform(this.geoCenter, i), h.multiplyVec3(i, d, d), s.dot(a, d) < 0 && (this.heading = (this.heading + 180) % 360), 
        this.computeViewMatrix(), this.hasCollision() && (this.geoCenter = r, this.computeViewMatrix());
    }, ct.prototype.rotate = function(t, e) {
        var r = this.heading, i = this.tilt;
        this.heading += .1 * t, this.tilt += .1 * e, this.computeViewMatrix(), this.hasCollision() && (this.heading = r, 
        this.tilt = i, this.computeViewMatrix());
    };
    var dt = function(t, e) {
        ut.prototype.constructor.call(this, t.renderContext, e), this.globe = t, this.minDistance = e && e.minDistance || .01, 
        this.maxDistance = e && e.maxDistance || 7, this.geoCenter = [ 0, 0, 0 ], this.distance = 7 * this.globe.coordinateSystem.radius, 
        this.up = [ 0, 1, 0 ], this.eye = [ 0, 0, this.distance ], this.computeViewMatrix();
    };
    m.inherits(ut, dt), dt.prototype.save = function() {
        return {
            geoCenter: this.geoCenter,
            eye: this.eye,
            up: this.up
        };
    }, dt.prototype.restore = function(t) {
        this.geoCenter = t.geoCenter, this.eye = t.eye, this.up = t.up, this.computeViewMatrix();
    }, dt.prototype.computeViewMatrix = function() {
        var t = this.renderContext.viewMatrix;
        h.lookAt(this.eye, this.geoCenter, this.up, t), this.up = [ t[1], t[5], t[9] ], 
        this.publish("modified"), this.renderContext.requestFrame();
    }, dt.prototype.zoom = function(t, e) {
        this.eye[2];
        e ? this.distance *= e : this.distance *= 1 + .1 * t, this.distance > this.maxDistance && (this.distance = this.maxDistance), 
        this.distance < this.minDistance && (this.distance = this.minDistance), this.eye[2] = this.distance, 
        this.computeViewMatrix();
    }, dt.prototype.pan = function(t, e) {
        var r = this.renderContext.canvas.width / 2, i = this.renderContext.canvas.height / 2, n = G.createFromPixel(this.renderContext, r - t, i - e);
        this.geoCenter = n.computePoint(n.planeIntersect([ 0, 0, 0 ], [ 0, 0, 1 ])), s.subtract(this.geoCenter, [ 0, 0, -this.distance ], this.eye), 
        this.computeViewMatrix();
    }, dt.prototype.rotate = function(t, e) {
        var r = .1 * -t * Math.PI / 180, i = s.create();
        s.subtract(this.geoCenter, this.eye, i), s.normalize(i);
        var n = l.fromAngleAxis(r, i);
        l.multiplyVec3(n, this.up), this.computeViewMatrix();
    };
    var ft = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    }, pt = /^(\w{2})(\w{2})(\w{2})$/, mt = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, vt = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/, gt = function(t) {
        if (this.strokeColor = [ 1, 0, 0, 1 ], this.fillColor = [ 1, 0, 0, 1 ], this.fillTextureUrl = null, 
        this.fillTexture = null, this.fillShader = null, this.strokeWidth = 1, this.iconUrl = null, 
        this.icon = null, this.label = null, this.textColor = [ 1, 1, 1, 1 ], this.fill = !1, 
        this.pointMaxSize = 40, this.opacity = 1, this.zIndex = 0, this.extrusionScale = 1, 
        t) for (var e in t) this[e] = t[e];
    };
    gt.fromStringToColor = function(t) {
        var e, r = 0, i = 0, n = 0, o = 255;
        return t = t.trim(), t = t.toLowerCase(), "#" == t.charAt(0) && (t = t.substr(1, 6)), 
        ft.hasOwnProperty(t) && (t = ft[t]), e = pt.exec(t), e && (r = parseInt(e[1], 16), 
        i = parseInt(e[2], 16), n = parseInt(e[3], 16)), e = mt.exec(t), e && (r = parseInt(e[1]), 
        i = parseInt(e[2]), n = parseInt(e[3])), e = vt.exec(t), e && (r = parseInt(e[1]), 
        i = parseInt(e[2]), n = parseInt(e[3]), o = parseInt(e[4])), r = r < 0 ? 0 : r > 255 ? 255 : r, 
        i = i < 0 ? 0 : i > 255 ? 255 : i, n = n < 0 ? 0 : n > 255 ? 255 : n, o = o < 0 ? 0 : o > 255 ? 255 : o, 
        [ r / 255, i / 255, n / 255, o / 255 ];
    }, gt.fromColorToString = function(t) {
        for (var e = "#", r = 0; r < 3; r++) {
            var i = parseInt(255 * t[r]).toString(16);
            e += i < 10 ? "0" + i : i;
        }
        return e;
    };
    var yt = function(t, e) {
        t.stats = this, this.renderContext = t;
        var r = e ? e.element : void 0;
        r && ("string" == typeof r ? this.element = document.getElementById(r) : this.element = r), 
        this.showFPS = this.renderContext.continuousRendering, this.verbose = !(!e || !e.verbose) && e.verbose, 
        this.numFrames = 0;
        var i = this;
        window.setInterval(function() {
            i.print();
        }, 1e3);
    };
    yt.prototype.start = function(t) {
        this[t] = Date.now();
    }, yt.prototype.end = function(t) {
        var e = Date.now() - this[t], r = this["max_" + t] || -1;
        r < e && (r = e);
        var i = this["sum_" + t] || 0;
        i += e, this[t] = e, this["max_" + t] = r, this["sum_" + t] = i, "globalRenderTime" == t && this.numFrames++;
    }, yt.prototype.print = function() {
        if (this.numFrames > 0) {
            var t = "";
            this.showFPS && (t += "FPS : " + this.numFrames + "<br>"), t += "Average render time : " + (this.sum_globalRenderTime / this.numFrames).toFixed(2) + " ms", 
            this.renderContext.renderers[0].getRenderStats && (t += "<br>" + this.renderContext.renderers[0].getRenderStats()), 
            this.verbose && (t += "<br>Average traverse tiles time : " + (this.sum_traverseTime / this.numFrames).toFixed(2) + " ms", 
            t += "<br>Average render tiles time : " + (this.sum_renderTime / this.numFrames).toFixed(2) + " ms", 
            t += "<br>Average generate tiles time : " + (this.sum_generateTime / this.numFrames).toFixed(2) + " ms", 
            t += "<br>Average request tiles time : " + (this.sum_requestTime / this.numFrames).toFixed(2) + " ms", 
            t += "<br>Max render time : " + this.max_globalRenderTime + " ms", t += "<br>Max traverse tiles time : " + this.max_traverseTime + " ms", 
            t += "<br>Max render tiles time : " + this.max_renderTime + " ms", t += "<br>Max generate tiles time : " + this.max_generateTime + " ms", 
            t += "<br>Max request tiles time : " + this.max_requestTime + " ms"), this.element.innerHTML = t, 
            this.sum_globalRenderTime = 0, this.sum_traverseTime = 0, this.sum_renderTime = 0, 
            this.sum_generateTime = 0, this.sum_requestTime = 0, this.max_globalRenderTime = 0, 
            this.max_traverseTime = 0, this.max_renderTime = 0, this.max_generateTime = 0, this.max_requestTime = 0, 
            this.numFrames = 0;
        }
    };
    var xt = function() {
        var t = {
            type: "FeatureCollection",
            features: []
        }, e = {}, r = /^(\w{2})(\w{2})(\w{2})(\w{2})$/, i = function(t) {
            var e = r.exec(t);
            return e ? [ parseInt(e[4], 16) / 255, parseInt(e[3], 16) / 255, parseInt(e[2], 16) / 255, parseInt(e[1], 16) / 255 ] : [ 1, 1, 1, 1 ];
        }, n = function(t) {
            for (var e = [], r = t.trim().split(/[\s,]+/), i = 0; i < r.length; i += 3) e.push([ parseFloat(r[i]), parseFloat(r[i + 1]), parseFloat(r[i + 2]) ]);
            return e;
        }, o = function(t, e) {
            switch (t.nodeName) {
              case "MultiGeometry":
                for (var r = [], i = t.childNodes, s = 0; s < i.length; s++) {
                    var a = o(i[s], e);
                    a && r.push(a);
                }
                return {
                    type: "GeometryCollection",
                    geometries: r
                };

              case "LineString":
                var h = t.getElementsByTagName("coordinates");
                if (1 == h.length) return {
                    type: "LineString",
                    coordinates: n(h[0].textContent)
                };
                break;

              case "Polygon":
                var l = t.getElementsByTagName("extrude");
                1 == l.length && (e.extrude = 0 != parseInt(l[0].childNodes[0].nodeValue)), e && (e.fill = !0);
                var u = t.getElementsByTagName("outerBoundaryIs"), h = u[0].getElementsByTagName("coordinates");
                if (1 == h.length) return {
                    type: "Polygon",
                    coordinates: [ n(h[0].textContent) ]
                };
                break;

              case "Point":
                var h = t.getElementsByTagName("coordinates");
                if (1 == h.length) {
                    var c = h[0].textContent.split(",");
                    return {
                        type: "Point",
                        coordinates: [ parseFloat(c[0]), parseFloat(c[1]) ]
                    };
                }
            }
            return null;
        }, s = function(r) {
            for (var i = {
                type: "Feature",
                properties: {},
                geometry: null
            }, n = !1, s = r.firstElementChild; s; ) {
                switch (s.nodeName) {
                  case "name":
                    i.properties.name = s.childNodes[0].nodeValue;
                    break;

                  case "styleUrl":
                    var a = s.childNodes[0].nodeValue;
                    e.hasOwnProperty(a) && (i.properties.style = e[a], n = !0);
                    break;

                  case "Style":
                    var h = d(s, i.properties.name, i.properties.style);
                    h && (i.properties.style = h);
                    break;

                  default:
                    null == i.geometry && (i.geometry = o(s, h));
                }
                s = s.nextElementSibling;
            }
            if (i.geometry) {
                var h = i.properties.style;
                h && h.textColor[3] > 0 && "Point" == i.geometry.type && (n && (h = i.properties.style = new gt(h)), 
                h.label = i.properties.name), t.features.push(i);
            }
        }, a = function(t) {
            for (var e = t.firstElementChild; e; ) {
                switch (e.nodeName) {
                  case "visibility":
                    var r = parseInt(e.textContent);
                    if (0 == r) return;
                    break;

                  case "Style":
                    d(e);
                    break;

                  default:
                    f(e);
                }
                e = e.nextElementSibling;
            }
        }, h = function(t, e) {
            for (var r = t.firstElementChild; r; ) {
                switch (r.nodeName) {
                  case "color":
                    e.fillColor = i(r.childNodes[0].nodeValue);
                }
                r = r.nextElementSibling;
            }
        }, l = function(t, e) {
            for (var r = t.firstElementChild; r; ) {
                switch (r.nodeName) {
                  case "color":
                    e.strokeColor = i(r.childNodes[0].nodeValue);
                    break;

                  case "width":
                    e.strokeWidth = parseFloat(r.childNodes[0].nodeValue);
                }
                r = r.nextElementSibling;
            }
        }, u = function(t, e) {
            for (var r = t.firstElementChild; r; ) {
                switch (r.nodeName) {
                  case "color":
                    break;

                  case "Icon":
                    r.firstElementChild ? e.iconUrl = r.firstElementChild.childNodes[0].nodeValue : e.iconUrl = null;
                }
                r = r.nextElementSibling;
            }
        }, c = function(t, e) {
            for (var r = t.firstElementChild; r; ) {
                switch (r.nodeName) {
                  case "color":
                    var n = i(r.textContent.trim());
                    0 == n[3] && (e.label = null, e.textColor = n);
                }
                r = r.nextElementSibling;
            }
        }, d = function(t, r) {
            var i = "#" + t.getAttribute("id"), n = new gt(r);
            e[i] = n;
            for (var o = t.firstElementChild; o; ) {
                switch (o.nodeName) {
                  case "PolyStyle":
                    h(o, n);
                    break;

                  case "LineStyle":
                    l(o, n);
                    break;

                  case "IconStyle":
                    u(o, n);
                    break;

                  case "LabelStyle":
                    c(o, n);
                }
                o = o.nextElementSibling;
            }
            return n;
        }, f = function(t) {
            switch (t.nodeName) {
              case "Style":
                d(t);
                break;

              case "Placemark":
                s(t);
                break;

              case "Document":
              case "Folder":
                a(t);
            }
        }, p = function(e) {
            for (var r = e.documentElement, i = r.firstElementChild; i; ) f(i), i = i.nextElementSibling;
            return t;
        };
        return {
            parse: p
        };
    }(), bt = function(t) {
        ot.prototype.constructor.call(this), this.globe = t.globe, this.speed = t.speed * this.globe.coordinateSystem.heightScale / 1e3, 
        this.nodes = [];
        for (var e = 0; e < t.coords.length; e++) {
            var r = {
                position: this.globe.coordinateSystem.fromGeoTo3D(t.coords[e]),
                velocity: null,
                distance: 0
            };
            if (this.nodes.push(r), e > 0) {
                var i = this.nodes[e].position[0] - this.nodes[e - 1].position[0], n = this.nodes[e].position[1] - this.nodes[e - 1].position[1], o = this.nodes[e].position[2] - this.nodes[e - 1].position[2];
                this.nodes[e - 1].distance = Math.sqrt(i * i + n * n + o * o);
            }
        }
        for (var e = 1; e < t.coords.length - 1; e++) {
            var a = s.subtract(this.nodes[e + 1].position, this.nodes[e].position, s.create()), l = s.subtract(this.nodes[e - 1].position, this.nodes[e].position, s.create());
            s.normalize(a), s.normalize(l), this.nodes[e].velocity = s.subtract(a, l, s.create()), 
            s.normalize(this.nodes[e].velocity);
        }
        var u = s.subtract(this.nodes[1].position, this.nodes[0].position, s.create());
        s.scale(u, 3 / this.nodes[0].distance), this.nodes[0].velocity = s.subtract(u, this.nodes[1].velocity, s.create()), 
        s.scale(this.nodes[0].velocity, .5);
        var e = t.coords.length - 1, u = s.subtract(this.nodes[e].position, this.nodes[e - 1].position, s.create());
        s.scale(u, 3 / this.nodes[e - 1].distance), this.nodes[e].velocity = s.subtract(u, this.nodes[e - 1].velocity, s.create()), 
        s.scale(this.nodes[e].velocity, .5), this.index = 0, this.currentDistance = 0, this.previousTime = -1, 
        this.currentDirection = [], this.centerOffset = -.2, this.altitudeOffset = 1e3;
        var c = this;
        t.setter ? this.valueSetter = t.setter : this.valueSetter = function(e, r) {
            var i, n = s.normalize(e, s.create());
            if (t.globe) {
                var o = t.globe.coordinateSystem.from3DToGeo(e);
                o[2] = t.globe.getElevation(o[0], o[1]) + c.altitudeOffset, i = t.globe.coordinateSystem.fromGeoTo3D(o);
            } else i = e, i[2] += c.altitudeOffset;
            var a = s.normalize(r, s.create()), l = s.add(i, a, s.create());
            s.add(l, s.scale(n, c.centerOffset, s.create())), h.lookAt(i, l, n, c.renderContext.viewMatrix);
        };
    };
    m.inherits(ot, bt), bt.prototype.setSpeed = function(t) {
        this.speed = parseFloat(t) * this.globe.coordinateSystem.heightScale / 1e3;
    }, bt.prototype.setAltitudeOffset = function(t) {
        this.altitudeOffset = parseFloat(t);
    }, bt.prototype.setDirectionAngle = function(t) {
        this.centerOffset = Math.tan(parseFloat(t) * Math.PI / 180);
    }, bt.prototype.start = function() {
        var t = -1;
        this.pauseTime != -1 && (t = this.startTime), ot.prototype.start.call(this), t != -1 ? this.previousTime += this.startTime - t : this.previousTime = -1;
    }, bt.prototype.update = function(t) {
        for (this.previousTime == -1 ? (this.index = 0, this.currentDistance = 0) : this.currentDistance += (t - this.previousTime) * this.speed, 
        this.previousTime = t; this.currentDistance >= this.nodes[this.index].distance && this.index < this.nodes.length - 1; ) this.currentDistance -= this.nodes[this.index].distance, 
        this.index = this.index + 1;
        if (this.index < this.nodes.length - 1) {
            var r = this.currentDistance / this.nodes[this.index].distance, i = this.nodes[this.index].position, n = this.nodes[this.index + 1].position, o = s.scale(this.nodes[this.index].velocity, this.nodes[this.index].distance, s.create()), a = s.scale(this.nodes[this.index + 1].velocity, this.nodes[this.index].distance, s.create()), h = e.cubicInterpolation(r, i, o, n, a), l = e.cubicInterpolationDerivative(r, i, o, n, a);
            this.valueSetter(h, l);
        } else this.index == this.nodes.length - 1 ? this.valueSetter(this.nodes[this.index].position, this.nodes[this.index].velocity) : this.stop();
    };
    var Tt = function(t) {
        this.manager = t, this.renderables = [];
    };
    Tt.prototype.initChild = function(t, e, r) {
        for (var i, n = 0; n < this.renderables.length; n++) if (this.renderables[n].initChild) {
            var o = this.renderables[n].initChild(e, r, t);
            o && (i || (i = t.extension.renderer = new Tt(this.manager)), i.renderables.push(o));
        }
    }, Tt.prototype.traverse = function(t, e) {
        for (var r = 0; r < this.renderables.length; r++) {
            var i = this.renderables[r], n = i.bucket;
            if (n.layer._visible && n.layer._opacity > 0) if (i.traverse) i.traverse(this.manager, t, e); else {
                if (i.hasChildren && !e) continue;
                this.manager.renderables.push(i);
            }
        }
    }, Tt.prototype.getRenderable = function(t) {
        for (var e = 0; e < this.renderables.length; e++) if (t == this.renderables[e].bucket) return this.renderables[e];
        return null;
    }, Tt.prototype.dispose = function(t, e) {
        for (var r = 0; r < this.renderables.length; r++) this.renderables[r].dispose(t, e);
        this.renderables.length = 0;
    };
    var _t = function(t) {
        this.tileManager = t.tileManager, this.globe = t, this.buckets = [], this.maxTilePerGeometry = 100, 
        this.levelZeroTiledGeometries = [];
    };
    _t.prototype.findBucket = function(t, e) {
        for (var r = 0; r < this.buckets.length; r++) {
            var i = this.buckets[r];
            if (i.layer == t && i.isCompatible(e)) return i;
        }
        return null;
    }, _t.prototype.generateLevelZero = function(t) {
        for (var e = 0; e < this.levelZeroTiledGeometries.length; e++) {
            for (var r = this.levelZeroTiledGeometries[e], i = !1, n = 0; n < r._tileIndices.length && !i; n++) {
                var o = this.tileManager.level0Tiles[r._tileIndices[n]];
                i = o == t;
            }
            i && this._addGeometryToTile(r._bucket, r, t);
        }
    }, _t.prototype._recursiveAddGeometryToTile = function(t, e, r) {
        var i = this._addGeometryToTile(t, e, r);
        if (i && i.generateChild && r.children) for (var n = 0; n < 4; n++) r.children[n].state == p.State.LOADED && (i.hasChildren = !0, 
        this._recursiveAddGeometryToTile(t, e, r.children[n]));
    }, _t.prototype.addGeometry = function(t, e, r) {
        var i = this.getOrCreateBucket(t, e, r);
        e._bucket = i;
        var n = this.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(e) : null;
        if (n && n.length < this.maxTilePerGeometry) {
            for (var o = 0; o < n.length; o++) {
                var s = this.tileManager.level0Tiles[n[o]];
                s.state == p.State.LOADED && this._recursiveAddGeometryToTile(i, e, s);
            }
            e._tileIndices = n, this.levelZeroTiledGeometries.push(e);
        } else i.mainRenderable || (i.mainRenderable = i.createRenderable()), i.mainRenderable.add(e);
    }, _t.prototype.removeGeometry = function(t) {
        var e = t._tileIndices;
        if (e) {
            for (var r = 0; r < e.length; r++) {
                var i = this.tileManager.level0Tiles[e[r]];
                this.removeGeometryFromTile(t, i);
            }
            this.levelZeroTiledGeometries.splice(this.levelZeroTiledGeometries.indexOf(t), 1), 
            t._tileIndices = null;
        } else {
            var n = t._bucket;
            if (n.mainRenderable) {
                var o = n.mainRenderable.remove(t);
                0 == o && (n.mainRenderable.dispose(this.renderContext), n.mainRenderable = null);
            }
        }
    }, _t.prototype.getOrCreateBucket = function(t, e, r) {
        var i = this.findBucket(t, r);
        return i || (i = this.createBucket(t, r), i.renderer = this, i.id = this.globe.vectorRendererManager.bucketId++, 
        this.buckets.push(i)), i;
    }, _t.prototype.addGeometryToTile = function(t, e, r, i) {
        var n = this.getOrCreateBucket(t, e, r);
        return e._bucket = n, this._addGeometryToTile(n, e, i);
    }, _t.prototype._addGeometryToTile = function(t, e, r) {
        var i = r.extension.renderer;
        i || (i = r.extension.renderer = new Tt(this.globe.vectorRendererManager));
        var n = i.getRenderable(t), o = !1;
        return n || (n = t.createRenderable(), o = !0), n.add(e, r) ? (o && i.renderables.push(n), 
        n) : null;
    }, _t.prototype.removeGeometryFromTile = function(t, e) {
        var r = e.extension.renderer;
        if (r) for (var i = 0; i < r.renderables.length; ) {
            var n = r.renderables[i], o = n.bucket.renderer;
            if (o == this) {
                var s = n.remove(t);
                if (0 == s ? r.renderables.splice(i, 1) : i++, n.hasChildren && e.children) for (var a = 0; a < 4; a++) e.children[a].state == p.State.LOADED && this.removeGeometryFromTile(t, e.children[a]);
            } else i++;
        }
    };
    var Mt = function() {
        var t = 18, e = 1, r = null, i = function() {
            r = document.createElement("canvas"), r.width = 512, r.height = t + 2 * e;
        }, n = function(n, o) {
            r || i();
            var s = o;
            s ? s instanceof Array && (s = gt.fromColorToString(o)) : s = "#fff";
            var a = r.getContext("2d");
            a.clearRect(0, 0, r.width, r.height), a.fillStyle = s, a.font = t + "px sans-serif", 
            a.textBaseline = "top", a.shadowColor = "#000", a.shadowOffsetX = 1, a.shadowOffsetY = 1, 
            a.shadowBlur = 2, a.fillText(n, e, e);
            var h = a.measureText(n);
            return a.getImageData(0, 0, Math.floor(h.width) + 2 * e, r.height);
        };
        return {
            generateImageData: n
        };
    }(), Rt = function(t) {
        _t.prototype.constructor.call(this, t), this.renderContext = t.tileManager.renderContext, 
        this.tileConfig = t.tileManager.tileConfig, this.numberOfRenderPoints = 0;
        var e = "\tattribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\tuniform mat4 viewProjectionMatrix; \n\tuniform vec3 poiPosition; // world position \n\tuniform vec2 poiScale; // x,y scale \n\tuniform vec2 tst; \n\t\n\tvarying vec2 texCoord; \n\t\n\tvoid main(void)  \n\t{ \n\t\t// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\t\ttexCoord = vertex.xy + vec2(0.5) + tst; \n\t\t// Invert y \n\t\ttexCoord.y = 1.0 - texCoord.y; \n\t\t\n\t\t// Compute poi position in clip coordinate \n\t\tgl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\t\tgl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\t} \n\t", r = "\tprecision lowp float; \n\tvarying vec2 texCoord; \n\tuniform sampler2D texture; \n\tuniform float alpha; \n\tuniform vec3 color; \n\t\n\tvoid main(void) \n\t{ \n\t\tvec4 textureColor = texture2D(texture, texCoord); \n\t\tgl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\t\tif (gl_FragColor.a <= 0.0) discard; \n\t} \n\t";
        this.program = new k(this.renderContext), this.program.createFromSource(e, r);
        var i = new Float32Array([ -.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0 ]), n = this.renderContext.gl;
        this.vertexBuffer = n.createBuffer(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), 
        n.bufferData(n.ARRAY_BUFFER, i, n.STATIC_DRAW), this.defaultTexture = null;
    };
    m.inherits(_t, Rt), Rt.prototype._buildDefaultTexture = function(t) {
        if (!this.defaultTexture) {
            var e = this.renderContext.gl;
            this.defaultTexture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.defaultTexture);
            var r = new Uint8Array([ 255, 255, 255, 255 ]);
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, r);
        }
        t.texture = this.defaultTexture, t.textureWidth = 10, t.textureHeight = 10;
    }, Rt.prototype._buildTextureFromImage = function(t, e) {
        t.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(e), t.textureWidth = e.width, 
        t.textureHeight = e.height;
    };
    var St = function(t) {
        this.bucket = t, this.points = [];
    };
    St.prototype.add = function(t) {
        var e = t.coordinates, r = this.bucket.layer.globe.coordinateSystem.fromGeoTo3D(e), i = s.create();
        return s.normalize(r, i), this.points.push({
            pos3d: r,
            vertical: i,
            geometry: t
        }), !0;
    }, St.prototype.remove = function(t) {
        for (var e = 0; e < this.points.length; e++) if (this.points[e].geometry == t) return this.points.splice(e, 1), 
        this.points.length;
        return this.points.length;
    }, St.prototype.dispose = function(t) {};
    var wt = function(t, e) {
        this.layer = t, this.style = new gt(e), this.renderer = null, this.texture = null;
    };
    wt.prototype.createRenderable = function() {
        return new St(this);
    }, wt.prototype.isCompatible = function(t) {
        return this.style.iconUrl == t.iconUrl && this.style.icon == t.icon && this.style.label == t.label;
    }, Rt.prototype.createBucket = function(t, e) {
        var r = new wt(t, e);
        if (e.label) {
            var i = Mt.generateImageData(e.label, e.textColor);
            this._buildTextureFromImage(r, i);
        } else if (e.iconUrl) {
            var n = new Image();
            n.crossOrigin = "";
            var o = this;
            n.onload = function() {
                o._buildTextureFromImage(r, n), o.renderContext.requestFrame();
            }, n.onerror = function() {
                o._buildDefaultTexture(r);
            }, n.src = e.iconUrl;
        } else e.icon ? this._buildTextureFromImage(r, e.icon) : this._buildDefaultTexture(r);
        return r;
    }, Rt.prototype.render = function(t, e, r) {
        this.numberOfRenderPoints = 0;
        var i = this.renderContext, n = this.renderContext.gl;
        n.enable(n.BLEND), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), 
        this.program.apply(), h.multiply(i.projectionMatrix, i.viewMatrix, i.modelViewMatrix), 
        n.uniformMatrix4fv(this.program.uniforms.viewProjectionMatrix, !1, i.modelViewMatrix), 
        n.uniform1i(this.program.uniforms.texture, 0), h.inverse(i.viewMatrix, i.modelViewMatrix);
        var o = [ i.modelViewMatrix[8], i.modelViewMatrix[9], i.modelViewMatrix[10] ];
        s.normalize(o), s.scale(o, this.tileConfig.cullSign, o);
        var a = i.computePixelSizeVector();
        n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.vertexAttribPointer(this.program.attributes.vertex, 3, n.FLOAT, !1, 0, 0);
        for (var l = null, u = e; u < r; u++) {
            var c = t[u], d = c.bucket;
            if (0 != c.points.length) {
                if (d != l) {
                    n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, d.texture);
                    var f = [ 2 * d.textureWidth / i.canvas.width, 2 * d.textureHeight / i.canvas.height ];
                    n.uniform2fv(this.program.uniforms.poiScale, f), n.uniform2fv(this.program.uniforms.tst, [ .5 / d.textureWidth, .5 / d.textureHeight ]);
                }
                for (var p = 0; p < c.points.length; p++) {
                    var m = c.points[p].pos3d, v = c.points[p].vertical, f = d.textureHeight * (a[0] * m[0] + a[1] * m[1] + a[2] * m[2] + a[3]);
                    f *= this.tileConfig.cullSign;
                    var g = f / this.globe.coordinateSystem.heightScale * .001;
                    if (!(g > d.style.pointMaxSize) && s.dot(v, o) > 0 && i.worldFrustum.containsSphere(m, f) >= 0) {
                        var y = v[0] * f + m[0], x = v[1] * f + m[1], b = v[2] * f + m[2];
                        n.uniform3f(this.program.uniforms.poiPosition, y, x, b), n.uniform1f(this.program.uniforms.alpha, d.layer._opacity);
                        var T = d.style.fillColor;
                        n.uniform3f(this.program.uniforms.color, T[0], T[1], T[2]), n.drawArrays(n.TRIANGLE_FAN, 0, 4), 
                        this.numberOfRenderPoints++;
                    }
                }
            }
        }
        n.disable(n.BLEND);
    }, Rt.prototype.canApply = function(t, e) {
        return "Point" == t;
    }, z.factory.push(function(t) {
        return new Rt(t);
    });
    var Pt = function(t) {
        this.bucket = t, this.vertexBuffer = null, this.indexBuffer = null, this.vertices = [], 
        this.triIndices = [], this.lineIndices = [], this.geometryInfos = [], this.bufferDirty = !0, 
        this.vertexSize = 3, this.indexType = 0, this.vertexBufferShared = !1;
    };
    Pt.prototype.remove = function(t) {
        for (var e = -1, r = 0, i = 0, n = 0, o = 0; o < this.geometryInfos.length; o++) {
            var s = this.geometryInfos[o];
            if (s.geometry == t) {
                this.vertices.splice(r, s.vertexCount), this.lineIndices.splice(i, s.lineIndexCount), 
                this.triIndices.splice(n, s.triIndexCount);
                for (var a = s.vertexCount / this.vertexSize, h = i; h < this.lineIndices.length; h++) this.lineIndices[h] -= a;
                for (var h = n; h < this.triIndices.length; h++) this.triIndices[h] -= a;
                e = o;
                break;
            }
            r += s.vertexCount, i += s.lineIndexCount, n += s.triIndexCount;
        }
        return e >= 0 ? (this.bufferDirty = !0, this.geometryInfos.splice(e, 1), this.vertices.length) : this.vertices.length;
    }, Pt.prototype.add = function(t, e) {
        this.tile = e;
        var r = this.vertices.length, i = this.lineIndices.length, n = this.triIndices.length, o = this.build(t, e);
        return !!o && (this.geometryInfos.push({
            geometry: t,
            vertexCount: this.vertices.length - r,
            lineIndexCount: this.lineIndices.length - i,
            triIndexCount: this.triIndices.length - n
        }), this.bufferDirty = !0, !0);
    }, Pt.prototype.dispose = function(t) {
        var e = t.gl;
        this.indexBuffer && e.deleteBuffer(this.indexBuffer), this.indexBuffer = null, this.vertexBuffer && !this.vertexBufferShared && (e.deleteBuffer(this.vertexBuffer), 
        this.vertexBuffer = null);
    }, Pt.prototype.bindBuffers = function(t) {
        var e = t.gl;
        if (this.bufferDirty) {
            this.dispose(t), this.vertexBuffer ? e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer) : (this.vertexBuffer = e.createBuffer(), 
            e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.vertices), e.STATIC_DRAW)), 
            this.indexBuffer = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var r = this.triIndices;
            r = this.triIndices.length > 0 ? this.lineIndices.length > 0 ? this.triIndices.concat(this.lineIndices) : this.triIndices : this.lineIndices;
            var i = this.vertices.length / this.vertexSize;
            i > 65535 ? (e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint32Array(r), e.STATIC_DRAW), 
            this.indexType = e.UNSIGNED_INT) : (e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array(r), e.STATIC_DRAW), 
            this.indexType = e.UNSIGNED_SHORT), this.bufferDirty = !1;
        } else e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    };
    var Et = function(t) {
        Pt.prototype.constructor.call(this, t), this.tile = null, this.hasChildren = !0;
    };
    m.inherits(Pt, Et), Et.prototype.initChild = function(t, e) {
        var r = new Et(this.bucket);
        return r.tile = this.tile, r.vertexBufferShared = !0, r.vertexBuffer = this.vertexBuffer, 
        r.vertices = this.vertices, r.buildChildrenIndices(this, 2 * e + t), r;
    }, Et.prototype.generateChild = function(t) {
        for (var e = 0; e < this.geometryInfos.length; e++) this.bucket.renderer._addGeometryToTile(this.bucket, this.geometryInfos[e].geometry, t);
    }, Et.prototype.buildChildrenIndices = function(t, e) {
        for (var r = 0; r < t.triIndices.length; r += 3) {
            var i = 3 * t.triIndices[r], n = 3 * t.triIndices[r + 1], o = 3 * t.triIndices[r + 2], s = t.vertices[i], a = t.vertices[n], h = t.vertices[o], l = 0;
            (s > 0 || 0 == s && a > 0 || 0 == s && 0 == a && h > 0) && (l = 1);
            var u = t.vertices[i + 1], c = t.vertices[n + 1], d = t.vertices[o + 1], f = 1;
            (u > 0 || 0 == u && c > 0 || 0 == u && 0 == c && d > 0) && (f = 0), e == 2 * f + l && this.triIndices.push(t.triIndices[r], t.triIndices[r + 1], t.triIndices[r + 2]);
        }
        for (var r = 0; r < t.lineIndices.length / 2; r++) {
            var i = 3 * t.lineIndices[2 * r], n = 3 * t.lineIndices[2 * r + 1], s = t.vertices[i], a = t.vertices[n], l = 0;
            (s > 0 || 0 == s && a > 0) && (l = 1);
            var u = t.vertices[i + 1], c = t.vertices[n + 1], f = 1;
            (u > 0 || 0 == u && c > 0) && (f = 0), e == 2 * f + l && this.lineIndices.push(t.lineIndices[2 * r], t.lineIndices[2 * r + 1]);
        }
    }, Et.prototype.build = function(t, e) {
        this.tile = e;
        var r = this.bucket.layer.minLevel <= e.level && this.bucket.layer.maxLevel > e.level;
        if (r) {
            var i = t.coordinates;
            switch (t.type) {
              case "LineString":
                this.buildVerticesAndIndices(e, i);
                break;

              case "Polygon":
                for (var n = 0; n < i.length; n++) this.buildVerticesAndIndices(e, i[n]);
                break;

              case "MultiLineString":
                for (var n = 0; n < i.length; n++) this.buildVerticesAndIndices(e, i[n]);
                break;

              case "MultiPolygon":
                for (var o = 0; o < i.length; o++) for (var n = 0; n < i[o].length; n++) this.buildVerticesAndIndices(e, i[o][n]);
            }
        }
        return e.geoBound.intersectsGeometry(t);
    };
    var Ct = function(t) {
        _t.prototype.constructor.call(this, t);
        var e = "\tattribute vec3 vertex; \n\tuniform float zOffset; \n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\t\n\tvoid main(void)  \n\t{ \n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n\t} \n\t", r = "\t#ifdef GL_ES \n\tprecision highp float; \n\t#endif \n\tuniform vec4 color; \n\t\n\tvoid main(void) \n\t{ \n\t\tgl_FragColor = color; \n\t} \n\t";
        this.program = new k(this.tileManager.renderContext), this.program.createFromSource(e, r);
    };
    m.inherits(_t, Ct), Ct.prototype.render = function(t, e, r) {
        var i = this.tileManager.renderContext, n = i.gl, o = h.create();
        this.program.apply(), n.depthFunc(n.LEQUAL), n.depthMask(!1), n.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, i.projectionMatrix);
        for (var s = null, a = e; a < r; a++) {
            var l = t[a], u = l.tile;
            h.multiply(i.viewMatrix, u.matrix, o), n.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, o), 
            n.uniform1f(this.program.uniforms.zOffset, 7e-4 * u.radius);
            var s = l.bucket.style;
            if (l.bindBuffers(i), n.vertexAttribPointer(this.program.attributes.vertex, 3, n.FLOAT, !1, 0, 0), 
            l.triIndices.length > 0 && (n.uniform4f(this.program.uniforms.color, s.fillColor[0], s.fillColor[1], s.fillColor[2], s.fillColor[3] * l.bucket.layer._opacity), 
            n.drawElements(n.TRIANGLES, l.triIndices.length, l.indexType, 0)), l.lineIndices.length > 0) {
                n.lineWidth(s.strokeWidth), n.uniform4f(this.program.uniforms.color, s.strokeColor[0], s.strokeColor[1], s.strokeColor[2], s.strokeColor[3] * l.bucket.layer._opacity);
                var c = l.indexType == n.UNSIGNED_INT ? 4 : 2;
                n.drawElements(n.LINES, l.lineIndices.length, l.indexType, l.triIndices.length * c);
            }
        }
        n.depthMask(!0), n.depthFunc(n.LESS);
    };
    var It = function(t) {
        Et.prototype.constructor.call(this, t);
    };
    m.inherits(Et, It), It.prototype._fixDateLine = function(t, e) {
        for (var r = [], i = [ r ], n = 0; n < e.length - 1; n++) {
            r.push(e[n]);
            var o = e[n][0], s = e[n][1], a = e[n + 1][0], h = e[n + 1][1];
            if (Math.abs(a - o) > 180) {
                o < 0 && (o += 360), a < 0 && (a += 360);
                var l = (180 - o) / (a - o);
                if (l > 0 && l < 1) {
                    var u = s + l * (h - s), c = e[n][0] > 0 ? 180 : -180;
                    r.push([ c, u ]), r = [ [ -c, u ] ], i.push(r);
                }
            }
        }
        return r.push(e[e.length - 1]), i;
    }, It.prototype.buildVerticesAndIndices = function(t, e) {
        if (0 != e.length) for (var r = this._fixDateLine(t, e), i = 0; i < r.length; i++) this._buildVerticesAndIndices(t, r[i]);
    }, It.prototype._buildVerticesAndIndices = function(t, r) {
        var i = t.config.tesselation, n = t.config.vertexSize;
        r.push(r[r.length - 1]);
        for (var o = t.lonlat2tile(r), s = 0; s < r.length - 1; s++) {
            for (var a = o[s][0], h = o[s][1], l = o[s + 1][0], u = o[s + 1][1], c = [], d = Math.max(-1, Math.min(a, l)), f = Math.min(i - 1, Math.max(a, l)), p = Math.floor(d) + 1; p < Math.floor(f) + 1; p++) {
                var m = p, v = e.lineIntersection(a, h, l, u, m, 0, m, i - 1);
                if (v[0] > 0 && v[0] < 1 && v[1] >= 0 && v[1] <= 1) {
                    var g = v[1] * (i - 1), y = Math.floor(g), x = g - y, b = n * (y * i + p), T = (1 - x) * t.vertices[b] + x * t.vertices[b + n * i], _ = (1 - x) * t.vertices[b + 1] + x * t.vertices[b + n * i + 1], M = (1 - x) * t.vertices[b + 2] + x * t.vertices[b + n * i + 2];
                    c.push([ v[0], T, _, M ]);
                }
            }
            for (var R = Math.max(-1, Math.min(h, u)), S = Math.min(i - 1, Math.max(h, u)), p = Math.floor(R) + 1; p < Math.floor(S) + 1; p++) {
                var g = p, v = e.lineIntersection(a, h, l, u, 0, g, i - 1, g);
                if (v[0] > 0 && v[0] < 1 && v[1] >= 0 && v[1] <= 1) {
                    var m = v[1] * (i - 1), w = Math.floor(m), P = m - w, b = n * (p * i + w), T = (1 - P) * t.vertices[b] + P * t.vertices[b + n], _ = (1 - P) * t.vertices[b + 1] + P * t.vertices[b + n + 1], M = (1 - P) * t.vertices[b + 2] + P * t.vertices[b + n + 2];
                    c.push([ v[0], T, _, M ]);
                }
            }
            c.sort(function(t, e) {
                return t[0] > e[0];
            });
            var E = this.vertices.length / 3;
            if (a >= 0 && a <= i - 1 && h >= 0 && h <= i - 1) {
                var C = t.computePosition(a, h);
                this.vertices.push(C[0]), this.vertices.push(C[1]), this.vertices.push(C[2]);
            }
            for (var p = 0; p < c.length; p++) this.vertices.push(c[p][1]), this.vertices.push(c[p][2]), 
            this.vertices.push(c[p][3]);
            if (l >= 0 && l <= i - 1 && u >= 0 && u <= i - 1) {
                var C = t.computePosition(l, u);
                this.vertices.push(C[0]), this.vertices.push(C[1]), this.vertices.push(C[2]);
            }
            for (var I = this.vertices.length / 3, p = E; p < I - 1; p++) this.lineIndices.push(p), 
            this.lineIndices.push(p + 1);
        }
    };
    var Lt = function(t) {
        Ct.prototype.constructor.call(this, t);
    };
    m.inherits(Ct, Lt), Lt.prototype.canApply = function(t, e) {
        return !this.globe.isSky && !("LineString" != t && "MultiLineString" != t && (e.fill || "Polygon" != t && "MultiPolygon" != t) || e.gradientLength);
    };
    var Ft = function(t, e) {
        this.layer = t, this.style = new gt(e), this.renderer = null;
    };
    Ft.prototype.createRenderable = function() {
        return new It(this);
    }, Ft.prototype.isCompatible = function(t) {
        return this.style.strokeColor[0] == t.strokeColor[0] && this.style.strokeColor[1] == t.strokeColor[1] && this.style.strokeColor[2] == t.strokeColor[2] && this.style.strokeColor[3] == t.strokeColor[3] && this.style.strokeWidth == t.strokeWidth;
    }, Lt.prototype.createBucket = function(t, e) {
        return new Ft(t, e);
    }, z.factory.push(function(t) {
        return new Lt(t);
    });
    var At = {
        REVISION: "2.1.1"
    };
    At.Math = {
        random: Math.random,
        array_shuffle: function(t) {
            for (var e = t.length - 1; e > 0; e--) {
                var r = Math.floor(At.Math.random() * (e + 1)), i = t[e];
                t[e] = t[r], t[r] = i;
            }
            return t;
        },
        compare_pts_yx: function(t, e) {
            var r = t.y - e.y;
            if (r < At.Math.EPSILON_N) return -1;
            if (r > At.Math.EPSILON_P) return 1;
            var i = t.x - e.x;
            return i < At.Math.EPSILON_N ? -1 : i > At.Math.EPSILON_P ? 1 : 0;
        },
        ptsCrossProd: function(t, e, r) {
            return (e.x - t.x) * (r.y - t.y) - (e.y - t.y) * (r.x - t.x);
        }
    }, At.Math.EPSILON_P = Math.pow(2, -43), At.Math.EPSILON_N = -At.Math.EPSILON_P, 
    At.PolygonData = function(t) {
        if (this.vertices = [], this.segments = [], this.diagonals = [], this.idNextPolyChain = 0, 
        this.PolyLeftArr = [], this.monoSubPolyChains = [], this.triangles = [], t) for (var e = 0, r = t.length; e < r; e++) this.addPolygonChain(t[e]);
    }, At.PolygonData.prototype = {
        constructor: At.PolygonData,
        nbVertices: function() {
            return this.vertices.length;
        },
        getSegments: function() {
            return this.segments;
        },
        getFirstSegment: function() {
            return this.segments[0];
        },
        getMonoSubPolys: function() {
            return this.monoSubPolyChains;
        },
        getTriangles: function() {
            return this.triangles.concat();
        },
        nbPolyChains: function() {
            return this.idNextPolyChain;
        },
        get_PolyLeftArr: function() {
            return this.PolyLeftArr.concat();
        },
        set_PolyLeft_wrong: function(t) {
            this.PolyLeftArr[t] = !1;
        },
        isClockWise: function(t) {
            var e = t, r = 0;
            do r += (e.vFrom.x - e.vTo.x) * (e.vFrom.y + e.vTo.y), e = e.snext; while (e != t);
            return r < 0;
        },
        appendVertexEntry: function(t, e) {
            var r = {
                id: this.vertices.length,
                x: t,
                y: e
            };
            return this.vertices.push(r), r;
        },
        createSegmentEntry: function(t, e) {
            return {
                chainId: this.idNextPolyChain,
                vFrom: t,
                vTo: e,
                upward: 1 == At.Math.compare_pts_yx(e, t),
                sprev: null,
                snext: null,
                rootFrom: null,
                rootTo: null,
                is_inserted: !1,
                trLeft: null,
                trRight: null,
                mprev: null,
                mnext: null,
                marked: !1
            };
        },
        appendSegmentEntry: function(t) {
            return this.segments.push(t), t;
        },
        appendDiagonalsEntry: function(t) {
            return this.diagonals.push(t), t;
        },
        addVertexChain: function(t) {
            function e(t, e) {
                return Math.abs(t.x - e.x) < At.Math.EPSILON_P && Math.abs(t.y - e.y) < At.Math.EPSILON_P;
            }
            function r(t, e, r) {
                if (Math.abs(At.Math.ptsCrossProd(e, t, r)) > At.Math.EPSILON_P) return !1;
                var i, n, o;
                return Math.abs(t.y - e.y) < At.Math.EPSILON_P ? (n = e.x, t.x < r.x ? (i = t.x, 
                o = r.x) : (i = r.x, o = t.x)) : (n = e.y, t.y < r.y ? (i = t.y, o = r.y) : (i = r.y, 
                o = t.y)), i - n < At.Math.EPSILON_P && n - o < At.Math.EPSILON_P;
            }
            for (var i, n, o, s = [], a = 0; a < t.length; a++) i = this.appendVertexEntry(t[a].x, t[a].y), 
            n = !0, o = s.length - 1, o >= 0 && (e(i, s[o]) ? n = !1 : o > 0 && r(s[o - 1], s[o], i) && s.pop()), 
            n && s.push(i);
            return o = s.length - 1, o > 0 && e(s[o], s[0]) && (s.pop(), o--), o > 1 && (r(s[o - 1], s[o], s[0]) && (s.pop(), 
            o--), o > 1 && r(s[o], s[0], s[1]) && s.shift()), s;
        },
        addPolygonChain: function(t) {
            var e = this.addVertexChain(t);
            if (e.length < 3) return console.log("Polygon has < 3 vertices!", e), 0;
            for (var r, i, n, o = this.segments.length, s = 0; s < e.length - 1; s++) r = this.createSegmentEntry(e[s], e[s + 1]), 
            n ? (r.sprev = n, n.snext = r) : i = r, n = r, this.appendSegmentEntry(r);
            return r = this.createSegmentEntry(e[e.length - 1], e[0]), r.sprev = n, n.snext = r, 
            this.appendSegmentEntry(r), i.sprev = r, r.snext = i, this.PolyLeftArr[this.idNextPolyChain++] = !0, 
            this.segments.length - o;
        },
        create_mono_chains: function() {
            for (var t, e, r, i, n = 0, o = this.segments.length; n < o; n++) t = this.segments[n], 
            this.PolyLeftArr[t.chainId] ? (e = t.vTo, t.mprev = t.sprev, t.mnext = t.snext) : (e = t.vFrom, 
            t = t.snext, t.mprev = t.snext, t.mnext = t.sprev), (i = t.vFrom.lastInDiag) && (i.mnext = t, 
            t.mprev = i, t.vFrom.lastInDiag = null), (r = e.firstOutDiag) && (r.mprev = t, t.mnext = r, 
            e.firstOutDiag = null);
        },
        unique_monotone_chains_max: function() {
            function t(t) {
                var e, r, i, n = t;
                for (r = i = t.vFrom, t.marked = !0, t = t.mnext; e = t.vFrom; ) {
                    if (t.marked) {
                        if (e == r) break;
                        return console.log("ERR unique_monotone: segment in two chains", r, t), null;
                    }
                    t.marked = !0, 1 == At.Math.compare_pts_yx(e, i) && (i = e, n = t), t = t.mnext;
                }
                return n;
            }
            var e, r;
            this.monoSubPolyChains = [];
            for (var i = 0, n = this.segments.length; i < n; i++) e = this.segments[i], e.marked || (r = t(e), 
            r && this.monoSubPolyChains.push(r));
            return this.monoSubPolyChains;
        },
        clearTriangles: function() {
            this.triangles = [];
        },
        addTriangle: function(t, e, r) {
            this.triangles.push([ t.id, e.id, r.id ]);
        }
    }, At.EarClipTriangulator = function(t) {
        this.polyData = t;
    }, At.EarClipTriangulator.prototype = {
        constructor: At.EarClipTriangulator,
        triangulate_polygon_no_holes: function() {
            function t(t) {
                var e = t.mprev.vFrom.x, r = t.mprev.vFrom.y, i = t.vFrom.x, n = t.vFrom.y, o = t.mnext.vFrom.x, s = t.mnext.vFrom.y, a = o - i, h = s - n, l = e - o, u = r - s, c = i - e, d = n - r;
                if (At.Math.EPSILON_P > c * h - a * d) return !1;
                for (var f = t.mprev.mprev, p = t.mnext; p != f; ) {
                    p = p.mnext;
                    var m = p.vFrom.x, v = p.vFrom.y, g = m - e, y = v - r;
                    if (0 !== g || 0 !== y) {
                        var x = m - i, b = v - n;
                        if (0 !== x || 0 !== b) {
                            var T = m - o, _ = v - s;
                            if ((0 !== T || 0 !== _) && a * b - h * x >= At.Math.EPSILON_N && c * y - d * g >= At.Math.EPSILON_N && l * _ - u * T >= At.Math.EPSILON_N) return !1;
                        }
                    }
                }
                return !0;
            }
            var e = this.polyData, r = e.getFirstSegment(), i = r;
            if (e.isClockWise(r)) {
                do i.mprev = i.snext, i.mnext = i.sprev, i = i.sprev; while (i != r);
                e.set_PolyLeft_wrong(0);
            } else do i.mprev = i.sprev, i.mnext = i.snext, i = i.snext; while (i != r);
            for (var n = r, o = n; n.mnext != n.mprev; ) if (t(n)) this.polyData.addTriangle(n.mprev.vFrom, n.vFrom, n.mnext.vFrom), 
            n.mprev.mnext = n.mnext, n.mnext.mprev = n.mprev, n = n.mnext, o = n; else if (n = n.mnext, 
            n == o) return !1;
            return !0;
        }
    }, At.Trapezoid = function(t, e, r, i) {
        this.vHigh = t ? t : {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
        }, this.vLow = e ? e : {
            x: Number.NEGATIVE_INFINITY,
            y: Number.NEGATIVE_INFINITY
        }, this.lseg = r, this.rseg = i, this.depth = -1, this.monoDone = !1;
    }, At.Trapezoid.prototype = {
        constructor: At.Trapezoid,
        clone: function() {
            var t = new At.Trapezoid(this.vHigh, this.vLow, this.lseg, this.rseg);
            return t.uL = this.uL, t.uR = this.uR, t.dL = this.dL, t.dR = this.dR, t.sink = this.sink, 
            t;
        },
        splitOffLower: function(t) {
            var e = this.clone();
            return this.vLow = e.vHigh = t, this.dL = e, e.uL = this, this.dR = e.uR = null, 
            e.dL && (e.dL.uL = e), e.dR && (e.dR.uR = e), e;
        }
    }, At.QsNode = function(t) {
        this.trap = t, t.sink = this;
    }, At.QsNode.prototype = {
        constructor: At.QsNode
    }, At.QueryStructure = function(t) {
        var e = new At.Trapezoid(null, null, null, null);
        if (this.trapArray = [], this.appendTrapEntry(e), this.root = new At.QsNode(e), 
        t) for (var r = t.getSegments(), i = 0; i < r.length; i++) r[i].rootFrom = r[i].rootTo = this.root, 
        r[i].is_inserted = !1;
    }, At.QueryStructure.prototype = {
        constructor: At.QueryStructure,
        getRoot: function() {
            return this.root;
        },
        appendTrapEntry: function(t) {
            t.trapID = this.trapArray.length, this.trapArray.push(t);
        },
        cloneTrap: function(t) {
            var e = t.clone();
            return this.appendTrapEntry(e), e;
        },
        splitNodeAtPoint: function(t, e, r) {
            var i = t.trap;
            if (i.vHigh == e) return t;
            if (i.vLow == e) return t;
            var n = i.splitOffLower(e);
            return this.appendTrapEntry(n), t.yval = e, t.trap = null, t.right = new At.QsNode(i), 
            t.left = new At.QsNode(n), r ? i.sink : n.sink;
        },
        fpEqual: function(t, e) {
            return Math.abs(t - e) < At.Math.EPSILON_P;
        },
        is_left_of: function(t, e, r) {
            var i, n = t.vFrom.x - e.x, o = t.vTo.x - e.x, s = this.fpEqual(t.vFrom.y, e.y);
            if (this.fpEqual(t.vTo.y, e.y)) {
                if (s) return 0;
                i = o;
            } else {
                if (!s) return t.upward ? At.Math.ptsCrossProd(t.vFrom, t.vTo, e) : At.Math.ptsCrossProd(t.vTo, t.vFrom, e);
                i = n;
            }
            return Math.abs(i) < At.Math.EPSILON_P ? 0 : i;
        },
        segNodes: function(t) {
            this.ptNode(t, !0), this.ptNode(t, !1);
        },
        ptNode: function(t, e) {
            var r, i, n;
            e ? (r = t.vFrom, i = t.vTo, n = t.rootFrom) : (r = t.vTo, i = t.vFrom, n = t.rootTo);
            for (var o, s; n; ) if (n.yval) n = At.Math.compare_pts_yx(r == n.yval ? i : r, n.yval) == -1 ? n.left : n.right; else {
                if (!n.seg) return n.trap || console.log("ptNode: unknown type", n), e ? t.rootFrom = n : t.rootTo = n, 
                n;
                if (r == n.seg.vFrom || r == n.seg.vTo) {
                    if (this.fpEqual(r.y, i.y)) {
                        this.fpEqual(n.seg.vFrom.y, n.seg.vTo.y) ? r == n.seg.vFrom ? (s = t.upward ? i.x >= n.seg.vTo.x : i.x < n.seg.vTo.x, 
                        n = (s ? t.sprev.upward : n.seg.snext.upward) ? n.right : n.left) : (s = t.upward ? i.x < n.seg.vFrom.x : i.x >= n.seg.vFrom.x, 
                        n = (s ? t.snext.upward : n.seg.sprev.upward) ? n.left : n.right) : n = i.x < r.x ? n.left : n.right;
                        continue;
                    }
                    o = this.is_left_of(n.seg, i, !1), 0 === o && (r == n.seg.vFrom ? (s = t.upward ? i.y >= n.seg.vTo.y : i.y < n.seg.vTo.y, 
                    o = s ? this.is_left_of(n.seg, t.sprev.vFrom, !1) : -this.is_left_of(n.seg, n.seg.snext.vTo, !1)) : (s = t.upward ? i.y < n.seg.vFrom.y : i.y >= n.seg.vFrom.y, 
                    o = s ? this.is_left_of(n.seg, t.snext.vTo, !1) : -this.is_left_of(n.seg, n.seg.sprev.vFrom, !1)));
                } else if (o = this.is_left_of(n.seg, r, !0), 0 === o && (o = this.is_left_of(n.seg, i, !1), 
                0 === o)) {
                    var a = e ? t.sprev.vFrom : t.snext.vTo;
                    o = this.is_left_of(n.seg, a, !1);
                }
                if (o > 0) n = n.left; else {
                    if (!(o < 0)) return n;
                    n = n.right;
                }
            }
        },
        add_segment: function(t) {
            function e() {
                var t = b.uL || b.uR;
                t.dL && t.dR ? b == t.dL ? (m.uL = null, t.dL = p) : (p.uR = null, t.dR = m) : (m.uL = null, 
                m.uR = t, t.dR = m);
            }
            function r() {
                b.usave ? (b.uleft ? (m.uL = b.uR, m.uR = b.usave, m.uL.dL = m, m.uR.dR = m) : (p.uR = b.uL, 
                p.uL = b.usave, p.uL.dL = p, p.uR.dR = p), p.usave = m.usave = null) : b.vHigh == f.vHigh ? (m.uR.dR = m, 
                p.uR = m.uL = null) : m == b ? (m.uL = m.uR, m.uR = null, m.uL.dL = m) : (p.uR = p.uL, 
                p.uL = null);
            }
            function i(t) {
                b.vLow == x.vLow ? (h ? b.dL ? (t.uL = p, p.dL = t, m.dR = null) : (t.uR = m, p.dL = null, 
                m.dR = t) : (t.uL = p, t.uR = m, p.dL = m.dR = t), p.dR = m.dL = null) : (t.uL && t.uR && (t.uL == b ? (t.usave = t.uR, 
                t.uleft = !0) : (t.usave = t.uL, t.uleft = !1)), t.uL = p, t.uR = m, p.dR = m.dL = t, 
                p.dL = m.dR = null);
            }
            function n() {
                var e;
                if (b.vLow == x.vLow && h) b.dL.uL = p, b.dR.uR = m, p.dL = b.dL, m.dR = b.dR, p.dR = m.dL = null, 
                e = null; else {
                    b.dL.uL = p, b.dR.uR = m;
                    var r, i = o.is_left_of(t, b.vLow, !0);
                    if (i > 0) r = !0; else if (i < 0) r = !1; else {
                        var n = b.dL.rseg, s = n.upward, a = s ? n.vFrom : n.vTo;
                        i = o.is_left_of(t, a, !1), i > 0 ? r = !0 : i < 0 ? r = !1 : (n = s ? n.snext : n.sprev, 
                        a = s ? n.vTo : n.vFrom, i = o.is_left_of(t, a, !1), r = i > 0);
                    }
                    r ? (e = b.dR, b.dR.uL = p, p.dL = b.dL, m.dR = null) : (e = b.dL, b.dL.uR = m, 
                    m.dR = b.dR, p.dL = null), p.dR = m.dL = e;
                }
                return e;
            }
            var o = this;
            this.segNodes(t);
            var s, a, h, l, u, c;
            if (t.upward ? (s = t.vFrom, l = t.vTo, a = t.rootFrom, u = t.rootTo, h = t.sprev.is_inserted, 
            c = t.snext.is_inserted) : (s = t.vTo, l = t.vFrom, a = t.rootTo, u = t.rootFrom, 
            h = t.snext.is_inserted, c = t.sprev.is_inserted), !c) {
                var d = this.splitNodeAtPoint(u, l, !1);
                u == a && (a = d), u = d;
            }
            var f = u.trap;
            if (!f.uL && !f.uR) return void console.log("ERR add_segment: missing trFirst.uX: ", f);
            if (f.vHigh != l) return void console.log("ERR add_segment: trFirstHigh != segHigh: ", f);
            h || (a = this.splitNodeAtPoint(a, s, !0));
            for (var p, m, v, g, y, x = a.trap, b = f, T = this.trapArray.length + 2; b; ) {
                if (--T < 0) return void console.log("ERR add_segment: infinite loop", b, t, this);
                if (!b.dL && !b.dR) return void console.log("ERR add_segment: missing successors", b, t, this);
                var _ = b.sink;
                _.seg = t, _.trap = null, g && g.rseg == b.rseg ? (p = b, m = g, m.vLow = b.vLow, 
                _.left = new At.QsNode(p), _.right = g.sink) : v && v.lseg == b.lseg ? (m = b, p = v, 
                p.vLow = b.vLow, _.left = v.sink, _.right = new At.QsNode(m)) : (p = b, m = this.cloneTrap(b), 
                _.left = new At.QsNode(p), _.right = new At.QsNode(m)), b.uL && b.uR ? r() : e(), 
                b.dL && b.dR ? y = n() : (y = b.dL ? b.dL : b.dR, i(y)), p.rseg && (p.rseg.trLeft = m), 
                m.lseg && (m.lseg.trRight = p), p.rseg = m.lseg = t, t.trLeft = p, t.trRight = m, 
                b.vLow != x.vLow ? (v = p, g = m, b = y) : b = null;
            }
            t.is_inserted = !0;
        },
        assignDepths: function(t) {
            var e, r, i = [ this.trapArray[0] ], n = [], o = 0;
            do {
                for (var s = o % 2 == 1; e = i.pop(); ) e.depth == -1 && (e.depth = o, e.uL && i.push(e.uL), 
                e.uR && i.push(e.uR), e.dL && i.push(e.dL), e.dR && i.push(e.dR), (r = e.lseg) && r.trLeft.depth == -1 && n.push(r.trLeft), 
                (r = e.rseg) && (r.trRight.depth == -1 && n.push(r.trRight), r.upward != s && t.set_PolyLeft_wrong(r.chainId)));
                i = n, n = [], o++;
            } while (i.length > 0);
        },
        create_visibility_map: function(t) {
            var e, r, i = 0, n = 1, o = 2, s = 3, a = 4, h = 5, l = 6, u = 7, c = t.nbVertices(), d = Array(c);
            for (e = 0; e < c; e++) d[e] = Array(u + 1);
            var f = Array(c);
            for (e = 0, r = this.trapArray.length; e < r; e++) {
                var p = this.trapArray[e], m = p.uL ? p.uR ? h : u : p.uR ? a : l, v = p.dL ? p.dR ? n : i : p.dR ? s : o;
                if (p.depth % 2 == 1) {
                    if (m == h || v == n || m == u && v == s || m == a && v == i) {
                        var g = t.appendDiagonalsEntry({
                            vFrom: p.vLow,
                            vTo: p.vHigh,
                            mprev: null,
                            mnext: null,
                            marked: !1
                        }), y = t.appendDiagonalsEntry({
                            vFrom: p.vHigh,
                            vTo: p.vLow,
                            revDiag: g,
                            mprev: null,
                            mnext: null,
                            marked: !1
                        });
                        g.revDiag = y, d[p.vLow.id][v] = g, d[p.vHigh.id][m] = y;
                    }
                } else null !== p.vHigh.id && (f[p.vHigh.id] = m), null !== p.vLow.id && (f[p.vLow.id] = v);
            }
            var x, b, T, _, M;
            for (e = 0; e < c; e++) if (b = d[e], T = f[e], null != T) {
                r = T, M = null;
                do r++ > u && (r = i), (x = b[r]) && (M ? (x.mprev = M, M.mnext = x) : (_ = x.vFrom, 
                _.firstOutDiag = x), M = x.revDiag); while (r != T);
                M && (_.lastInDiag = M);
            }
        }
    }, At.Trapezoider = function(t) {
        this.polyData = t, this.queryStructure = new At.QueryStructure(this.polyData);
    }, At.Trapezoider.prototype = {
        constructor: At.Trapezoider,
        optimise_randomlist: function(t) {
            var e = 0, r = this.polyData.nbPolyChains();
            if (1 != r) for (var i = Array(r), n = t.concat(), o = 0; o < n.length; o++) {
                var s = n[o].chainId;
                i[s] ? t[r++] = n[o] : (t[e++] = n[o], i[s] = !0);
            }
        },
        trapezoide_polygon: function() {
            var t = this.polyData.getSegments().concat();
            At.Math.array_shuffle(t), this.optimise_randomlist(t);
            for (var e, r = t.length, i = this.queryStructure, n = 0, o = r; n < r; ) {
                o = Math.log(o) / Math.LN2;
                for (var s = o > 1 ? Math.floor(r / o) : r; n < s; n++) i.add_segment(t[n]);
                for (e = n; e < r; e++) this.queryStructure.segNodes(t[e]);
            }
            for (i.assignDepths(this.polyData), e = 0; e < r; e++) t[e].trLeft = t[e].trRight = null;
        },
        create_visibility_map: function() {
            return this.queryStructure.create_visibility_map(this.polyData);
        }
    }, At.MonoSplitter = function(t) {
        this.polyData = t, this.trapezoider = null;
    }, At.MonoSplitter.prototype = {
        constructor: At.MonoSplitter,
        monotonate_trapezoids: function() {
            this.trapezoider = new At.Trapezoider(this.polyData), this.trapezoider.trapezoide_polygon(), 
            this.trapezoider.create_visibility_map(), this.polyData.create_mono_chains(), this.polyData.unique_monotone_chains_max();
        }
    }, At.MonoTriangulator = function(t) {
        this.polyData = t;
    }, At.MonoTriangulator.prototype = {
        constructor: At.MonoTriangulator,
        triangulate_all_polygons: function() {
            var t = this.polyData.getMonoSubPolys();
            this.polyData.clearTriangles();
            for (var e = 0; e < t.length; e++) {
                var r = t[e], i = r.mprev, n = r.mnext;
                n.mnext == i ? this.polyData.addTriangle(r.vFrom, n.vFrom, i.vFrom) : this.triangulate_monotone_polygon(r);
            }
        },
        triangulate_monotone_polygon: function(t) {
            function e() {
                for (console.log("ERR uni-y-monotone: only concave angles left", o); s > 1; ) s--, 
                r.polyData.addTriangle(o[s - 1], o[s], o[s + 1]);
            }
            var r = this, i = t.mnext, n = t.vFrom, o = [ i.vFrom ], s = 0;
            i = i.mnext;
            var a = i.vFrom;
            if (a != n) {
                for (;a != n || s > 1; ) if (s > 0) {
                    var h = At.Math.ptsCrossProd(o[s], a, o[s - 1]);
                    Math.abs(h) <= At.Math.EPSILON_P && (a != n && At.Math.compare_pts_yx(o[s], a) != At.Math.compare_pts_yx(o[s], o[s - 1]) || (h = 1)), 
                    h > 0 ? (this.polyData.addTriangle(o[s - 1], o[s], a), s--) : (o[++s] = a, a == n ? e() : (i = i.mnext, 
                    a = i.vFrom));
                } else o[++s] = a, i = i.mnext, a = i.vFrom;
                this.polyData.addTriangle(o[s - 1], o[s], a);
            }
        }
    }, At.Triangulator = function() {
        this.lastPolyData = null;
    }, At.Triangulator.prototype = {
        constructor: At.Triangulator,
        clear_lastData: function() {
            this.lastPolyData = null;
        },
        get_PolyLeftArr: function() {
            return this.lastPolyData ? this.lastPolyData.get_PolyLeftArr() : null;
        },
        triangulate_polygon: function(t, e) {
            function r() {
                return !e && 1 == n.nbPolyChains();
            }
            if (this.clear_lastData(), !t || 0 === t.length) return [];
            var i, n = new At.PolygonData(t), o = r();
            if (o && (i = new At.EarClipTriangulator(n), o = i.triangulate_polygon_no_holes()), 
            !o) {
                var s = new At.MonoSplitter(n);
                s.monotonate_trapezoids(), i = new At.MonoTriangulator(n), i.triangulate_all_polygons();
            }
            return this.lastPolyData = n, n.getTriangles();
        }
    };
    var Dt = function(t) {
        _t.prototype.constructor.call(this, t), this.maxTilePerGeometry = 2, this.renderContext = t.renderContext, 
        this.defaultVertexShader = "\t\tattribute vec3 vertex;\n\t\tuniform mat4 mvp;\n\t\tvoid main(void) \n\t\t{\n\t\t\tgl_Position = mvp * vec4(vertex, 1.0);\n\t\t}\n\t", 
        this.extrudeVertexShader = "\t\tattribute vec3 vertex;\n\t\tattribute vec4 normal;\n\t\tuniform float extrusionScale; \n\t\tuniform mat4 mvp;\n\t\tvoid main(void) \n\t\t{\n\t\t\tvec3 extrudedVertex = vertex + normal.w * vec3(normal.x, normal.y, normal.z) * extrusionScale;\t\t\tgl_Position = mvp * vec4(extrudedVertex, 1.0);\n\t\t}\n\t", 
        this.fragmentShader = "\tprecision lowp float; \n\tuniform vec4 u_color;\n\tvoid main(void)\n\t{\n\t\tgl_FragColor = u_color;\n\t\t//if (u_color.a == 0.0) discard;\n\t}\n\t", 
        this.program = new k(t.renderContext), this.program.createFromSource(this.defaultVertexShader, this.fragmentShader), 
        this.extrudeProgram = new k(t.renderContext), this.extrudeProgram.createFromSource(this.extrudeVertexShader, this.fragmentShader);
    };
    m.inherits(_t, Dt);
    var Bt = function(t) {
        Pt.prototype.constructor.call(this, t), this.origin = null, this.vertexSize = t.style.extrude ? 7 : 3, 
        this.matrix = h.create();
    };
    m.inherits(Pt, Bt), Bt.prototype.build = function(t) {
        var e = this.bucket.renderer, r = this.bucket.style, i = e.globe.coordinateSystem, n = "MultiPolygon" == t.type ? t.coordinates : [ t.coordinates ], o = s.create();
        this.origin || (this.origin = s.create(), i.fromGeoTo3D(n[0][0][0], this.origin), 
        h.identity(this.matrix), h.translate(this.matrix, this.origin));
        for (var a = this.vertices.length / this.vertexSize, l = this.vertices.length, u = 0; u < n.length; u++) {
            var c = n[u][0];
            l = this.vertices.length;
            for (var d = 0, f = 0; f < c.length; f++) {
                if (i.fromGeoTo3D([ c[f][0], c[f][1], 0 ], o), this.vertices[l] = o[0] - this.origin[0], 
                this.vertices[l + 1] = o[1] - this.origin[1], this.vertices[l + 2] = o[2] - this.origin[2], 
                f < c.length - 1 && (d += (c[f + 1][0] - c[f][0]) * (c[f + 1][1] + c[f][1])), r.extrude) {
                    s.normalize(o), this.vertices[l + 3] = o[0], this.vertices[l + 4] = o[1], this.vertices[l + 5] = o[2];
                    var p;
                    p = "boolean" == typeof r.extrude ? c[f][2] : r.extrude, this.vertices[l + 6] = p * i.heightScale;
                }
                l += this.vertexSize;
            }
            if (r.extrude) {
                var m = a * this.vertexSize;
                this.vertices = this.vertices.concat(this.vertices.slice(m, l));
                for (var f = l; f < this.vertices.length; f += this.vertexSize) this.vertices[f + 6] = 0;
            }
            for (var v = new At.Triangulator(), g = c.map(function(t) {
                return {
                    x: t[0],
                    y: t[1]
                };
            }), y = v.triangulate_polygon([ g ]), f = 0; f < y.length; f++) this.triIndices.push(a + y[f][0], a + y[f][1], a + y[f][2]);
            if (r.extrude) for (var x = a, b = a + c.length, f = 0; f < c.length - 1; f++) d > 0 ? (this.triIndices.push(x, x + 1, b), 
            this.triIndices.push(x + 1, b + 1, b)) : (this.triIndices.push(x, b, x + 1), this.triIndices.push(x + 1, b, b + 1)), 
            x += 1, b += 1;
            for (var f = 0; f < c.length - 1; f++) this.lineIndices.push(a + f, a + f + 1);
            if (r.extrude) for (var x = a, b = a + c.length, f = 0; f < c.length - 1; f++) this.lineIndices.push(x + f, b + f);
            a = this.vertices.length / this.vertexSize;
        }
        return !0;
    };
    var Ot = function(t, e) {
        this.layer = t, this.style = e, this.renderer = null;
    };
    Ot.prototype.createRenderable = function() {
        return new Bt(this);
    }, Ot.prototype.isCompatible = function(t) {
        return this.style == t;
    }, Dt.prototype.render = function(t, e, r) {
        var i = this.globe.renderContext, n = i.gl;
        n.enable(n.BLEND), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), 
        n.depthFunc(n.LEQUAL);
        var o = null, s = h.create();
        h.multiply(i.projectionMatrix, i.viewMatrix, s);
        for (var a = h.create(), l = e; l < r; l++) {
            var u = t[l], c = u.bucket.style, d = c.extrude ? this.extrudeProgram : this.program;
            if (d != o && (d.apply(), o = d), h.multiply(s, u.matrix, a), n.uniformMatrix4fv(d.uniforms.mvp, !1, a), 
            n.uniform4f(d.uniforms.u_color, c.fillColor[0], c.fillColor[1], c.fillColor[2], c.fillColor[3] * u.bucket.layer._opacity), 
            u.bindBuffers(i), n.lineWidth(c.strokeWidth), n.vertexAttribPointer(d.attributes.vertex, 3, n.FLOAT, !1, 4 * u.vertexSize, 0), 
            c.extrude && (n.vertexAttribPointer(d.attributes.normal, 4, n.FLOAT, !1, 4 * u.vertexSize, 12), 
            n.uniform1f(d.uniforms.extrusionScale, c.extrusionScale)), n.drawElements(n.TRIANGLES, u.triIndices.length, u.indexType, 0), 
            u.lineIndices.length > 0) {
                n.uniform4f(d.uniforms.u_color, c.strokeColor[0], c.strokeColor[1], c.strokeColor[2], c.strokeColor[3] * u.bucket.layer._opacity);
                var f = u.indexType == n.UNSIGNED_INT ? 4 : 2;
                n.drawElements(n.LINES, u.lineIndices.length, u.indexType, u.triIndices.length * f);
            }
        }
        n.lineWidth(1), n.depthFunc(n.LESS), n.disable(n.BLEND);
    }, Dt.prototype.canApply = function(t, e) {
        return ("Polygon" == t || "MultiPolygon" == t) && e.fill;
    }, Dt.prototype.createBucket = function(t, e) {
        return new Ot(t, e);
    }, z.factory.push(function(t) {
        return new Dt(t);
    });
    var Nt = function(t) {
        _t.prototype.constructor.call(this, t), this.maxTilePerGeometry = 2, this.renderContext = t.renderContext, 
        this.defaultVertexShader = "\t\tattribute vec4 vertex;\n\t\tuniform mat4 mvp;\n\t\tvarying float s;\n\t\tvoid main(void) \n\t\t{\n\t\t\ts = vertex.w;\n\t\t\tgl_Position = mvp * vec4(vertex.xyz, 1.0);\n\t\t}\n\t", 
        this.fragmentShader = "\tprecision lowp float; \n\tuniform vec4 u_color;\n\tuniform float speed;\n\tuniform float time;\n\tuniform float gradientLength;\n\tvarying float s;\n\tuniform sampler2D colorTexture;\n\tvoid main(void)\n\t{\n\t\t// 0.5 is a time scale parameter, parametrize it ?\n\t\tfloat m = speed * time * 0.5;\n\t\tfloat u = (-s+m)/gradientLength;\n\t\tgl_FragColor.rgb = texture2D(colorTexture, vec2(u,0.)).rgb;\n\t\t// TODO: handle appereance of rivers\n\t\tif ( s < m )\n\t\t{\n\t\t\tgl_FragColor.a = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgl_FragColor.a = 0.0;\n\t\t}\n\t}\n\t", 
        this.program = new k(t.renderContext), this.program.createFromSource(this.defaultVertexShader, this.fragmentShader), 
        this.time = Date.now() / 1e3, this.palette = null, this.colorTexture = this.generateTexture([ [ 0, 0, 255 ], [ 0, 200, 255 ] ]);
    };
    m.inherits(_t, Nt), Nt.prototype.generateTexture = function(t) {
        var r = t[0], i = t[1], n = [], o = this.globe.renderContext.gl;
        this.colorTexture = o.createTexture(), o.bindTexture(o.TEXTURE_2D, this.colorTexture);
        for (var s = 0; s < 128; s++) {
            var a = e.coserp(s / 128, r[0], i[0]), h = e.coserp(s / 128, r[1], i[1]), l = e.coserp(s / 128, r[2], i[2]);
            n.push(a), n.push(h), n.push(l), n.push(255);
        }
        for (var s = 0; s < 128; s++) {
            var a = e.coserp(s / 128, i[0], r[0]), h = e.coserp(s / 128, i[1], r[1]), l = e.coserp(s / 128, i[2], r[2]);
            n.push(a), n.push(h), n.push(l), n.push(255);
        }
        o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, n.length / 4, 1, 0, o.RGBA, o.UNSIGNED_BYTE, new Uint8Array(n)), 
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), 
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.REPEAT), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.REPEAT), 
        this.palette = t;
    };
    var kt = function(t) {
        Pt.prototype.constructor.call(this, t), this.vertexSize = 4, this.matrix = h.create(), 
        h.identity(this.matrix);
    };
    m.inherits(Pt, kt), kt.prototype.build = function(t) {
        for (var e = this.bucket.renderer, r = (this.bucket.style, "MultiLineString" == t.type ? t.coordinates : [ t.coordinates ]), i = s.create(), n = s.create(), o = 0; o < r.length; o++) {
            for (var a = r[o], h = this.vertices.length / 4, l = e.globe.coordinateSystem, u = 4 * h, c = 0, d = 0; d < a.length; d++) {
                l.fromGeoTo3D(a[d], i), this.vertices[u] = i[0], this.vertices[u + 1] = i[1], this.vertices[u + 2] = i[2], 
                d > 0 && (c += s.dist(i, n));
                var f = n;
                n = i, i = f, this.vertices[u + 3] = c, u += 4;
            }
            for (var d = 0; d < a.length - 1; d++) this.lineIndices.push(h + d, h + d + 1);
        }
        return !0;
    };
    var Ut = function(t, e) {
        this.layer = t, this.style = e, this.renderer = null;
    };
    Ut.prototype.createRenderable = function() {
        return new kt(this);
    }, Ut.prototype.isCompatible = function(t) {
        return this.style == t;
    }, Nt.prototype.render = function(t, e, r) {
        var i = this.globe.renderContext, n = i.gl;
        n.enable(n.BLEND), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), 
        n.depthFunc(n.LEQUAL);
        var o = h.create();
        h.multiply(i.projectionMatrix, i.viewMatrix, o);
        var s = h.create();
        this.program.apply(), n.activeTexture(n.TEXTURE0), n.uniform1i(this.program.uniforms.colorTexture, 0), 
        n.bindTexture(n.TEXTURE_2D, this.colorTexture);
        for (var a = e; a < r; a++) {
            var l = t[a], u = l.bucket.style;
            h.multiply(o, l.matrix, s), n.uniformMatrix4fv(this.program.uniforms.mvp, !1, s), 
            u.palette && u.palette != this.palette && (n.deleteTexture(this.colorTexture), this.generateTexture(u.palette)), 
            n.lineWidth(u.strokeWidth), n.uniform4f(this.program.uniforms.u_color, u.strokeColor[0], u.strokeColor[1], u.strokeColor[2], u.strokeColor[3] * l.bucket.layer._opacity), 
            n.uniform1f(this.program.uniforms.speed, u.hasOwnProperty("speed") ? u.speed : 1), 
            n.uniform1f(this.program.uniforms.time, Date.now() / 1e3 - this.time), n.uniform1f(this.program.uniforms.gradientLength, u.hasOwnProperty("gradientLength") ? u.gradientLength : 10), 
            l.bindBuffers(i), n.vertexAttribPointer(this.program.attributes.vertex, 4, n.FLOAT, !1, 0, 0), 
            n.drawElements(n.LINES, l.lineIndices.length, l.indexType, 0);
        }
        n.lineWidth(1), n.depthFunc(n.LESS), n.disable(n.BLEND);
    }, Nt.prototype.canApply = function(t, e) {
        return ("LineString" == t || "MultiLineString" == t) && e.gradientLength;
    }, Nt.prototype.createBucket = function(t, e) {
        return new Ut(t, e);
    }, z.factory.push(function(t) {
        return new Nt(t);
    });
    var qt = function(t) {
        this.Globe = new Y(t), this.CoordinateSystemFactory = tt, this.GeoBound = v, this.FeatureStyle = gt, 
        this.Navigation = ct, this.FlatNavigation = dt, this.Stats = yt, this.KMLParser = xt, 
        this.Numeric = e, this.PathAnimation = bt, this.SegmentedAnimation = ht;
    };
    qt.prototype.getGlobe = function() {
        return this.Globe;
    };
    var zt = function(t) {
        X.prototype.constructor.call(this, t), this.globe = null, this.name = t && t.hasOwnProperty("name") ? t.name : "", 
        this.attribution = t && t.hasOwnProperty("attribution") ? t.attribution : "", this.copyrightUrl = t && t.hasOwnProperty("copyrightUrl") ? t.copyrightUrl : "", 
        this.ack = t && t.hasOwnProperty("ack") ? t.ack : "", this.icon = t && t.hasOwnProperty("icon") ? t.icon : "", 
        this.description = t && t.hasOwnProperty("description") ? t.description : "", this._visible = !t || !t.hasOwnProperty("visible") || t.visible, 
        this._opacity = t && t.hasOwnProperty("opacity") ? t.opacity : 1, this.properties = t && t.hasOwnProperty("properties") ? t.properties : {};
    };
    m.inherits(X, zt), zt.prototype._attach = function(t) {
        this.globe = t, this.attribution && this.globe.attributionHandler && this._visible && this.globe.attributionHandler.addAttribution(this);
    }, zt.prototype._detach = function() {
        this.attribution && this.globe.attributionHandler && this.globe.attributionHandler.removeAttribution(this), 
        this.globe = null;
    }, zt.prototype.visible = function(t) {
        return "boolean" == typeof t && (this._visible != t && this.attribution && this.globe.attributionHandler && this.globe.attributionHandler.toggleAttribution(this), 
        this._visible = t, this.globe && this.globe.renderContext.requestFrame(), this.publish("visibility:changed", this)), 
        this._visible;
    }, zt.prototype.opacity = function(t) {
        return "number" == typeof t && (this._opacity = t, this.globe && this.globe.renderContext.requestFrame(), 
        this.publish("opacity:changed")), this._opacity;
    };
    var Vt = function(t) {
        this.vertexShader = "\tattribute vec3 vertex;\n\tattribute vec2 tcoord;\n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\tuniform vec4 textureTransform; \n\tvarying vec2 texCoord;\n\tvoid main(void) \n\t{\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\t\ttexCoord = tcoord * textureTransform.xy + textureTransform.zw;\n\t}\n\t", 
        this.fragmentShader = "\tprecision lowp float;\n\tvarying vec2 texCoord;\n\tuniform sampler2D overlayTexture;\n\tuniform float opacity; \n\tvoid main(void)\n\t{\n\t\tgl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n\t\tgl_FragColor.a *= opacity; \n\t}\n\t", 
        this.rendererManager = t.vectorRendererManager, this.tileManager = t.tileManager, 
        this.programs = [], this.program = this.createProgram({
            vertexCode: this.vertexShader,
            fragmentCode: this.fragmentShader,
            updateUniforms: null
        }), this.buckets = [], this.imageRequests = [], this.frameNumber = 0;
        for (var e = this, r = 0; r < 4; r++) {
            var i = new B({
                successCallback: function() {
                    this.renderable && (this.renderable.bucket.layer.handleImage && this.renderable.bucket.layer.handleImage(this), 
                    this.renderable.ownTexture = e.tileManager.tilePool.createGLTexture(this.image), 
                    this.renderable.texture = this.renderable.ownTexture, this.renderable.uvScale = 1, 
                    this.renderable.uTrans = 0, this.renderable.vTrans = 0, this.renderable.updateChildrenTexture(), 
                    this.renderable.onRequestFinished(!0), this.renderable = null, e.tileManager.renderContext.requestFrame());
                },
                failCallback: function() {
                    this.renderable && (this.renderable.onRequestFinished(!0), this.renderable = null);
                },
                abortCallback: function() {
                    this.renderable && (this.renderable.onRequestFinished(!1), this.renderable = null);
                }
            });
            this.imageRequests.push(i);
        }
    }, Gt = function(t) {
        this.bucket = t, this.ownTexture = null, this.texture = null, this.request = null, 
        this.requestFinished = !1, this.tile = null, this.uvScale = 1, this.uTrans = 0, 
        this.vTrans = 0;
    };
    Gt.prototype.onRequestStarted = function(t) {
        this.request = t, this.requestFinished = !1;
        var e = this.bucket.layer;
        0 == e._numRequests && e.globe.publish("startLoad", e), e._numRequests++;
    }, Gt.prototype.onRequestFinished = function(t) {
        this.request = null, this.requestFinished = t;
        var e = this.bucket.layer;
        e._numRequests--, e.globe && 0 == e._numRequests && e.globe.publish("endLoad", e);
    }, Gt.prototype.initChild = function(t, e, r) {
        var i = this.bucket.createRenderable();
        return i.tile = r, this.texture && (i.texture = this.texture, i.uvScale = this.uvScale, 
        i.uTrans = this.uTrans, i.vTrans = this.vTrans), i;
    }, Gt.prototype.generateChild = function(t) {
        var e = this.bucket.renderer;
        e.addOverlayToTile(t, this.bucket, this);
    }, Gt.prototype.updateChildrenTexture = function() {
        if (this.tile.children) for (var t = 0; t < 4; t++) {
            var e = this.tile.children[t].extension.renderer;
            if (e) {
                var r = e.getRenderable(this.bucket);
                r && !r.ownTexture && (r.updateTextureFromParent(this), r.updateChildrenTexture());
            }
        }
    }, Gt.prototype.updateTextureFromParent = function(t) {
        this.tile.state == p.State.LOADED ? (this.texture = t.texture, this.uvScale = .5 * t.uvScale, 
        this.uTrans = t.uTrans, this.vTrans = t.vTrans, this.uTrans += 1 & this.tile.parentIndex ? this.uvScale : 0, 
        this.vTrans += 2 & this.tile.parentIndex ? this.uvScale : 0) : (this.texture = t.texture, 
        this.uvScale = t.uvScale, this.uTrans = t.uTrans, this.vTrans = t.vTrans);
    }, Gt.prototype.traverse = function(t, e, r) {
        r && this.texture && t.renderables.push(this), this.requestFinished || this.tile.state != p.State.LOADED || this.bucket.renderer.requestOverlayTextureForTile(this);
    }, Gt.prototype.dispose = function(t, e) {
        this.ownTexture && (e.disposeGLTexture(this.ownTexture), this.ownTexture = null);
    };
    var Wt = function(t) {
        this.layer = t, this.renderer = null, this.style = t;
    };
    Wt.prototype.createRenderable = function() {
        return new Gt(this);
    }, Vt.prototype.addOverlay = function(t) {
        t._numRequests = 0;
        var e = new Wt(t);
        e.renderer = this, e.id = this.rendererManager.bucketId++, this.buckets.push(e), 
        t._bucket = e;
        for (var r = 0; r < this.tileManager.level0Tiles.length; r++) {
            var i = this.tileManager.level0Tiles[r];
            i.state == p.State.LOADED && this.addOverlayToTile(i, e);
        }
    }, Vt.prototype.removeOverlay = function(t) {
        var e = this.buckets.indexOf(t._bucket);
        this.buckets.splice(e, 1);
        var r = this.tileManager.renderContext, i = this.tileManager.tilePool;
        this.tileManager.visitTiles(function(e) {
            var n = e.extension.renderer, o = n ? n.getRenderable(t._bucket) : null;
            if (o) {
                var s = n.renderables.indexOf(o);
                n.renderables.splice(s, 1), o.dispose(r, i), 0 == n.renderables.length && delete e.extension.renderer;
            }
        });
    }, Vt.prototype.addOverlayToTile = function(t, e, r) {
        if (this.overlayIntersects(t.geoBound, e.layer)) {
            t.extension.renderer || (t.extension.renderer = new Tt(this.rendererManager));
            var i = e.createRenderable();
            if (i.tile = t, t.extension.renderer.renderables.push(i), r && r.texture && i.updateTextureFromParent(r), 
            t.children) for (var n = 0; n < 4; n++) t.children[n].state == p.State.LOADED && this.addOverlayToTile(t.children[n], e, i);
        }
    };
    var Xt = function(t, e, r) {
        return [ e[0] + t * (r[0] - e[0]), e[1] + t * (r[1] - e[1]) ];
    };
    Vt.prototype.clipPolygonToSide = function(t, e, r, i) {
        for (var n = [], o = 0; o < i.length; o++) {
            var s = i[o], a = i[(o + 1) % i.length], h = s[t], l = a[t], u = (h - r) * e >= 0, c = (l - r) * e >= 0;
            if (!u && c) {
                var d = (r - h) / (l - h), f = Xt(d, s, a);
                n.push(f), n.push(a);
            } else if (u && c) n.push(a); else if (u && !c) {
                var d = (r - h) / (l - h), f = Xt(d, s, a);
                n.push(f);
            }
        }
        return n;
    }, Vt.prototype.overlayIntersects = function(t, e) {
        if (e.coordinates) {
            var r;
            return r = this.clipPolygonToSide(0, 1, t.west, e.coordinates), r = this.clipPolygonToSide(0, -1, t.east, r), 
            r = this.clipPolygonToSide(1, 1, t.south, r), r = this.clipPolygonToSide(1, -1, t.north, r), 
            r.length > 0;
        }
        return !e.geoBound || e.geoBound.intersects(t);
    }, Vt.prototype.generateLevelZero = function(t) {
        for (var e = 0; e < this.buckets.length; e++) this.addOverlayToTile(t, this.buckets[e]);
    }, Vt.prototype.requestOverlayTextureForTile = function(t) {
        if (t.request) t.request.frameNumber = this.frameNumber; else {
            for (var e, r = 0; r < this.imageRequests.length; r++) if (!this.imageRequests[r].renderable) {
                e = this.imageRequests[r];
                break;
            }
            e && (t.onRequestStarted(e), e.renderable = t, e.frameNumber = this.frameNumber, 
            e.send(t.bucket.layer.getUrl(t.tile), t.bucket.layer.crossOrigin));
        }
    }, Vt.prototype.createProgram = function(t) {
        var e = new k(this.tileManager.renderContext);
        return e.createFromSource(this.vertexShader, t.fragmentCode), e.id = this.programs.length, 
        this.programs.push({
            fragmentCode: t.fragmentCode,
            program: e
        }), e;
    }, Vt.prototype.getProgram = function(t) {
        for (var e, r = 0; r < this.programs.length; r++) this.programs[r].fragmentCode == t.fragmentCode && (e = this.programs[r].program);
        return e || (e = this.createProgram(t)), e;
    }, Vt.prototype.render = function(t, e, r) {
        var i = this.tileManager.renderContext, n = i.gl;
        n.enable(n.BLEND), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), n.depthFunc(n.LEQUAL);
        for (var o = h.create(), s = null, a = null, l = e; l < r; l++) {
            var u, c, d = t[l], f = d.bucket, m = f.layer;
            m.customShader ? (c = this.getProgram(m.customShader), u = m.customShader.updateUniforms) : c = this.getProgram({
                vertexCode: this.vertexShader,
                fragmentCode: this.fragmentShader,
                updateUniforms: null
            }), c != a && (a = c, c.apply(), n.uniformMatrix4fv(c.uniforms.projectionMatrix, !1, i.projectionMatrix), 
            n.uniform1i(c.uniforms.overlayTexture, 0), n.bindBuffer(n.ARRAY_BUFFER, this.tileManager.tcoordBuffer), 
            n.vertexAttribPointer(c.attributes.tcoord, 2, n.FLOAT, !1, 0, 0)), u && u(n, c), 
            n.bindBuffer(n.ARRAY_BUFFER, d.tile.vertexBuffer), n.vertexAttribPointer(c.attributes.vertex, 3, n.FLOAT, !1, 4 * d.tile.config.vertexSize, 0);
            var v = d.tile.state == p.State.LOADED ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(d.tile.parentIndex);
            s != v && (n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, v), s = v), h.multiply(i.viewMatrix, d.tile.matrix, o), 
            n.uniformMatrix4fv(c.uniforms.modelViewMatrix, !1, o), n.uniform1f(c.uniforms.opacity, m._opacity), 
            n.uniform4f(c.uniforms.textureTransform, d.uvScale, d.uvScale, d.uTrans, d.vTrans), 
            n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, d.texture), n.drawElements(n.TRIANGLES, s.numIndices, n.UNSIGNED_SHORT, 0);
        }
        n.disable(n.BLEND), n.depthFunc(n.LESS);
    }, Vt.prototype.canApply = function(t, e) {
        return !1;
    };
    var Yt = function(t) {
        this.layer = t.layer, this.cacheLevel = t.hasOwnProperty("cacheLevel") ? t.cacheLevel : 1, 
        localStorage.getItem(this.layer.name) || localStorage.setItem(this.layer.name, JSON.stringify({})), 
        this._cacheMap = JSON.parse(localStorage.getItem(this.layer.name)), this.imgCanvas = document.createElement("canvas"), 
        this.imgCanvas.width = t.tilePixelSize || 256, this.imgCanvas.height = t.tilePixelSize || 256, 
        this.imgContext = this.imgCanvas.getContext("2d");
    };
    Yt.prototype.getFromCache = function(t) {
        var e = null;
        if (this.cacheLevel >= t.level) {
            var r = this.layer.getUrl(t), i = this._cacheMap[r];
            if (i) {
                i.lastAccess = Date.now();
                var n = new Image();
                n.src = i.dataUrl, n.dataType = "byte", e = {
                    image: n,
                    elevations: i.elevations
                };
            }
        }
        return e;
    }, Yt.prototype._createDataURL = function(t) {
        return this.imgContext.drawImage(t, 0, 0, t.width, t.height), this.imgCanvas.toDataURL("image/png");
    }, Yt.prototype.storeInCache = function(t) {
        var e = t.tile;
        if (this.cacheLevel >= e.level) {
            var r = this.layer.getUrl(e);
            this._cacheMap[r] = {
                dataUrl: this._createDataURL(t.image),
                elevations: t.elevations,
                lastAccess: Date.now()
            }, console.log("Stored for " + t.image.src), localStorage.setItem(this.layer.name, JSON.stringify(this._cacheMap));
        }
    };
    var Ht = function(t) {
        zt.prototype.constructor.call(this, t), this.tilePixelSize = -1, this.tiling = null, 
        this.numberOfLevels = -1, this.geoBound = t.geoBound || null, this.coordinates = t.coordinates || null, 
        this.zIndex = t.zIndex || 0, this.crossOrigin = t.crossOrigin || "anonymous", t.cache && (t.cache.layer = this, 
        this.cache = new Yt(t.cache)), this._overlay = !0, this._ready = !0;
    };
    m.inherits(zt, Ht), Ht.prototype._attach = function(t) {
        if (this._overlay || (this.id = 0), zt.prototype._attach.call(this, t), this._overlay) {
            if (!t.rasterOverlayRenderer) {
                var e = new Vt(t);
                t.vectorRendererManager.renderers.push(e), t.rasterOverlayRenderer = e;
            }
            t.rasterOverlayRenderer.addOverlay(this);
        }
    }, Ht.prototype._detach = function() {
        this._overlay && this.globe.rasterOverlayRenderer && this.globe.rasterOverlayRenderer.removeOverlay(this), 
        zt.prototype._detach.call(this);
    };
    var jt = function(t) {
        Ht.prototype.constructor.call(this, t), this.baseUrl = t.baseUrl, this.tilePixelSize = t.tilePixelSize || 256, 
        this.tiling = new L(4, 2), this.numberOfLevels = t.numberOfLevels || 21;
        var e = this.baseUrl;
        e += e.indexOf("?", 0) == -1 ? "?service=wms" : "&service=wms", e += "&version=", 
        e += t.hasOwnProperty("version") ? t.version : "1.1.1", e += "&request=GetMap", 
        e += "&layers=" + t.layers, e += "&styles=", t.hasOwnProperty("styles") && (e += t.styles), 
        e += "&format=", e += t.hasOwnProperty("format") ? t.format : "image/jpeg", t.hasOwnProperty("transparent") && (e += "&transparent=" + t.transparent), 
        e += "&width=", e += this.tilePixelSize, e += "&height=", e += this.tilePixelSize, 
        t.hasOwnProperty("time") && (e += "&time=" + t.time), this.getMapBaseUrl = e;
    };
    m.inherits(Ht, jt), jt.prototype.getUrl = function(t) {
        var e = t.bound, r = this.getMapBaseUrl;
        return r += "&srs=" + t.config.srs, r += "&bbox=", r += e.west, r += ",", r += e.south, 
        r += ",", r += e.east, r += ",", r += e.north;
    };
    var Zt = function(t) {
        Ht.prototype.constructor.call(this, t), this.baseUrl = t.baseUrl, this.tilePixelSize = t.tilePixelSize || 256, 
        this.tiling = new L(4, 2), this.numberOfLevels = t.numberOfLevels || 21, this.type = "ImageryRaster", 
        this.startLevel = t.startLevel || 1;
        var e = this.baseUrl;
        e += e.indexOf("?", 0) == -1 ? "?service=wmts" : "&service=wmts", e += "&version=", 
        e += t.version || "1.0.0", e += "&request=GetTile", e += "&layer=" + t.layer, e += "&tilematrixset=" + t.matrixSet, 
        t.style && (e += "&style=" + t.style), e += "&format=", e += t.format || "image/png", 
        t.time && (e += "&time=" + t.time), this.getTileBaseUrl = e;
    };
    m.inherits(Ht, Zt), Zt.prototype.getUrl = function(t) {
        var e = this.getTileBaseUrl;
        return e += "&tilematrix=", e += t.level + this.startLevel, e += "&tilecol=" + t.x, 
        e += "&tilerow=" + t.y;
    };
    var Qt = function(t) {
        Ht.prototype.constructor.call(this, t), this.baseUrl = t.baseUrl, this.tilePixelSize = t.tilePixelSize || 33, 
        this.tiling = new L(4, 2), this.numberOfLevels = t.numberOfLevels || 21, this.version = t.version || "2.0.0", 
        this.format = t.format || "image/x-aaigrid", this.minElevation = t.minElevation || 0, 
        this.scale = t.scale || 1;
        var e = this.baseUrl;
        switch (e += e.indexOf("?", 0) == -1 ? "?service=wcs" : "&service=wcs", e += "&version=" + this.version, 
        e += "&request=GetCoverage", this.version.substring(0, 3)) {
          case "2.0":
            this.crs = t.outputCRS || t.crs || "http://www.opengis.net/def/crs/EPSG/0/4326", 
            e += "&outputCRS=" + this.crs, e += "&size=x(" + this.tilePixelSize + ")", e += "&size=y(" + this.tilePixelSize + ")", 
            e += "&coverageid=" + t.coverage;
            break;

          case "1.0":
            e += "&width=" + this.tilePixelSize, e += "&height=" + this.tilePixelSize, e += "&crs=" + (t.crs || "EPSG:4326"), 
            e += "&coverage=" + t.coverage;
        }
        e += "&format=" + this.format, this.getCoverageBaseUrl = e;
    };
    m.inherits(Ht, Qt), Qt.prototype.parseElevations = function(t) {
        if (null == t) return this._returnZeroElevations();
        switch (this.format) {
          case "image/x-aaigrid":
            return this._parseAAIGrid(t);

          default:
            return console.log("Format '" + this.format + "' could not be parsed."), this._returnZeroElevations();
        }
    }, Qt.prototype._returnZeroElevations = function() {
        for (var t = [], e = 0; e < this.tilePixelSize * this.tilePixelSize; ++e) t.push(0);
        return t;
    }, Qt.prototype._parseAAIGrid = function(t) {
        for (var e = [], r = t.trim().split("\n"), i = 0, n = 0; n < r.length; ++n) if (" " === r[n].substring(0, 1)) {
            i = n;
            break;
        }
        for (var n = i; n < r.length; n++) for (var o = r[n].trim().split(/\s+/), s = 0; s < o.length; s++) {
            var a = parseInt(o[s]);
            a < this.minElevation && (a = this.minElevation), e.push(a * this.scale);
        }
        return e;
    }, Qt.prototype.getUrl = function(t) {
        var e = t.geoBound, r = this.getCoverageBaseUrl;
        return "2.0" === this.version.substring(0, 3) ? (r += "&subset=x," + this.crs + "(" + e.west + "," + e.east + ")", 
        r += "&subset=y," + this.crs + "(" + e.south + "," + e.north + ")") : "1.0" === this.version.substring(0, 3) && (r += "&bbox=", 
        r += e.west, r += ",", r += e.south, r += ",", r += e.east, r += ",", r += e.north), 
        r;
    };
    var Kt = function(t) {
        zt.prototype.constructor.call(this, t), t && t.style ? this.style = t.style : this.style = new gt(), 
        this.minLevel = t && t.hasOwnProperty("minLevel") ? t.minLevel : 0, this.maxLevel = t && t.hasOwnProperty("maxLevel") ? t.maxLevel : 15, 
        this.features = [];
    };
    m.inherits(zt, Kt), Kt.prototype._attach = function(t) {
        zt.prototype._attach.call(this, t);
        for (var e = 0; e < this.features.length; e++) this._addFeatureToRenderers(this.features[e]);
    }, Kt.prototype._detach = function() {
        for (var t = 0; t < this.features.length; t++) this._removeFeatureFromRenderers(this.features[t]);
        zt.prototype._detach.call(this);
    }, Kt.prototype.addFeatureCollection = function(t) {
        var e = t.features;
        if (e) for (var r = 0; r < e.length; r++) this.addFeature(e[r]);
    }, Kt.prototype.removeFeatureCollection = function(t) {
        var e = t.features;
        if (e) for (var r = 0; r < e.length; r++) this.removeFeature(e[r]);
    }, Kt.prototype._addFeatureToRenderers = function(t) {
        var e = t.geometry, r = this.style, i = t.properties;
        if (i && i.style && (r = i.style), "GeometryCollection" == e.type) for (var n = e.geometries, o = 0; o < n.length; o++) this.globe.vectorRendererManager.addGeometry(this, n[o], r); else this.globe.vectorRendererManager.addGeometry(this, e, r);
    }, Kt.prototype._removeFeatureFromRenderers = function(t) {
        var e = t.geometry;
        if ("GeometryCollection" == e.type) {
            for (var r = e.geometries, i = !1, n = 0; n < r.length; n++) i = this.globe.vectorRendererManager.removeGeometry(r[n], this);
            return i;
        }
        return this.globe.vectorRendererManager.removeGeometry(e, this);
    }, Kt.prototype.addFeature = function(t) {
        var e = t.geometry;
        e && e.type && (this.features.push(t), this.globe && (this._addFeatureToRenderers(t), 
        this._visible && this.globe.renderContext.requestFrame()));
    }, Kt.prototype.removeFeature = function(t) {
        var e = this.features.indexOf(t);
        this.features.splice(e, 1), this.globe && (this._removeFeatureFromRenderers(t), 
        this._visible && this.globe.renderContext.requestFrame());
    }, Kt.prototype.removeAllFeatures = function() {
        if (this.globe) for (var t = 0; t < this.features.length; t++) this._removeFeatureFromRenderers(this.features[t]);
        this.features.length = 0, this.globe && this._visible && this.globe.renderContext.requestFrame();
    }, Kt.prototype.modifyFeatureStyle = function(t, e) {
        this._removeFeatureFromRenderers(t) && (t.properties.style = e, this._addFeatureToRenderers(t));
    }, Kt.prototype.modifyStyle = function(t) {
        for (var e = 0; e < this.features.length; e++) this._removeFeatureFromRenderers(this.features[e]);
        this.style = t;
        for (var e = 0; e < this.features.length; e++) this._addFeatureToRenderers(this.features[e]);
    };
    var $t = function(t) {
        zt.prototype.constructor.call(this, t), this.name || (this.name = "Atmosphere"), 
        this.kr = t && t.kr || .0025, this.km = t && t.km || .0015, this.sunBrightness = t && t.sunBrightness || 15, 
        this.exposure = t && t.exposure || 2, this.wavelength = t && t.wavelength || [ .65, .57, .475 ], 
        this.lightDir = t && t.lightDir || [ 1, 0, 0 ], this._skyProgram = null, this._groundProgram = null, 
        this._originalProgram = null, this._isValid = !1, this.zIndex = -1;
    };
    m.inherits(zt, $t), $t.prototype._attach = function(t) {
        this.globe = t, this._innerRadius = this.globe.coordinateSystem.radius, this._outerRadius = 1.005 * this._innerRadius;
        var e = t.renderContext;
        if (this._skyFromSpaceProgram = new k(e), this._skyFromSpaceProgram.loadFromFile("SkyFromSpaceVert.glsl", "SkyFrag.glsl"), 
        this._skyFromAtmosphereProgram = new k(e), this._skyFromAtmosphereProgram.loadFromFile("SkyFromAtmosphereVert.glsl", "SkyFrag.glsl"), 
        this._groundFromSpaceProgram = new k(e), this._groundFromSpaceProgram.loadFromFile("GroundFromSpaceVert.glsl", "GroundFrag.glsl"), 
        this._groundFromAtmosphereProgram = new k(e), this._groundFromAtmosphereProgram.loadFromFile("GroundFromAtmosphereVert.glsl", "GroundFrag.glsl"), 
        this._isValid = null != this._skyFromSpaceProgram.glProgram && null != this._skyFromAtmosphereProgram.glProgram && null != this._groundFromSpaceProgram.glProgram && null != this._groundFromAtmosphereProgram.glProgram, 
        this._isValid) {
            this._skyFromSpaceProgram.apply(), this._initUniforms(this._skyFromSpaceProgram.uniforms), 
            this._skyFromAtmosphereProgram.apply(), this._initUniforms(this._skyFromAtmosphereProgram.uniforms), 
            this._groundFromSpaceProgram.apply(), this._initUniforms(this._groundFromSpaceProgram.uniforms), 
            this._groundFromAtmosphereProgram.apply(), this._initUniforms(this._groundFromAtmosphereProgram.uniforms);
            var r, i, n = [], o = [], s = 72, a = 144;
            for (r = -s; r <= s; r++) {
                var h = r * (.5 * Math.PI) / s;
                for (i = -a; i <= a; i++) {
                    var l = i * Math.PI / a, u = this._outerRadius * Math.cos(l) * Math.cos(h), c = this._outerRadius * Math.sin(l) * Math.cos(h), d = this._outerRadius * Math.sin(h);
                    n.push(u), n.push(c), n.push(d);
                }
            }
            for (r = 0; r < 2 * s; r++) for (i = 0; i < 2 * a; i++) o.push(r * (2 * a + 1) + i), 
            o.push((r + 1) * (2 * a + 1) + i + 1), o.push(r * (2 * a + 1) + i + 1), o.push((r + 1) * (2 * a + 1) + i + 1), 
            o.push(r * (2 * a + 1) + i), o.push((r + 1) * (2 * a + 1) + i);
            var f = e.gl;
            this._vertexBuffer = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, this._vertexBuffer), 
            f.bufferData(f.ARRAY_BUFFER, new Float32Array(n), f.STATIC_DRAW), this._indexBuffer = f.createBuffer(), 
            f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indexBuffer), f.bufferData(f.ELEMENT_ARRAY_BUFFER, new Uint16Array(o), f.STATIC_DRAW), 
            this._numIndices = o.length, this._originalProgram = t.tileManager.program, t.preRenderers.push(this), 
            t.tileManager.addPostRenderer(this);
        }
    }, $t.prototype._initUniforms = function(t) {
        var e = this.globe.renderContext.gl, r = -.95, i = 1 / (this._outerRadius - this._innerRadius), n = .25;
        s.normalize(this.lightDir), e.uniform1f(t.fKrESun, this.kr * this.sunBrightness), 
        e.uniform1f(t.fKmESun, this.kr * this.sunBrightness), e.uniform1f(t.fKr4PI, 4 * this.kr * Math.PI), 
        e.uniform1f(t.fKm4PI, 4 * this.km * Math.PI), e.uniform1f(t.fExposure, this.exposure);
        var o = [ Math.pow(this.wavelength[0], 4), Math.pow(this.wavelength[1], 4), Math.pow(this.wavelength[2], 4) ];
        e.uniform3f(t.v3InvWavelength, 1 / o[0], 1 / o[1], 1 / o[2]), e.uniform3f(t.v3LightPos, this.lightDir[0], this.lightDir[1], this.lightDir[2]), 
        e.uniform1f(t.fInnerRadius, this._innerRadius), e.uniform1f(t.fInnerRadius2, this._innerRadius * this._innerRadius), 
        e.uniform1f(t.fOuterRadius, this._outerRadius), e.uniform1f(t.fOuterRadius2, this._outerRadius * this._outerRadius), 
        e.uniform1f(t.fScale, i), e.uniform1f(t.fScaleDepth, n), e.uniform1f(t.fScaleOverScaleDepth, i / n), 
        e.uniform1f(t.g, r), e.uniform1f(t.g2, r * r);
    }, $t.prototype.preRender = function() {
        if (this._isValid) {
            var t = this.globe.tileManager;
            if (!this._visible) return void (t.program = this._originalProgram);
            var e = this.globe.renderContext, r = e.gl, i = e.viewMatrix, n = i[12], o = i[13], a = i[14], l = [ -(i[0] * n + i[1] * o + i[2] * a), -(i[4] * n + i[5] * o + i[6] * a), -(i[8] * n + i[9] * o + i[10] * a) ], u = s.length(l);
            this._skyProgram = u < this._outerRadius ? this._skyFromAtmosphereProgram : this._skyFromSpaceProgram, 
            this._groundProgram = u < this._outerRadius ? this._groundFromAtmosphereProgram : this._groundFromSpaceProgram, 
            this._skyProgram.apply(), r.uniform3f(this._skyProgram.uniforms.v3CameraPos, l[0], l[1], l[2]), 
            r.uniform1f(this._skyProgram.uniforms.fCameraHeight2, u * u), r.uniform1f(this._skyProgram.uniforms.fCameraHeight, u), 
            this._groundProgram.apply();
            var c = [ 0, 0, 0 ];
            h.multiplyVec3(e.viewMatrix, c), r.uniform3f(this._groundProgram.uniforms.earthCenter, c[0], c[1], c[2]), 
            s.normalize(this.lightDir);
            var n = this.lightDir[0], o = this.lightDir[1], a = this.lightDir[2], d = e.viewMatrix, f = [];
            f[0] = d[0] * n + d[4] * o + d[8] * a, f[1] = d[1] * n + d[5] * o + d[9] * a, f[2] = d[2] * n + d[6] * o + d[10] * a, 
            r.uniform3f(this._groundProgram.uniforms.lightDir, f[0], f[1], f[2]), r.uniform3f(this._groundProgram.uniforms.v3CameraPos, l[0], l[1], l[2]), 
            r.uniform1f(this._groundProgram.uniforms.fCameraHeight2, u * u), r.uniform1f(this._groundProgram.uniforms.fCameraHeight, u), 
            t.program = this._groundProgram;
        }
    }, $t.prototype.render = function() {
        if (this._isValid && this._visible) {
            var t = this.globe.renderContext, e = t.gl;
            e.enable(e.CULL_FACE), this._skyProgram.apply(), e.uniformMatrix4fv(this._skyProgram.uniforms.projectionMatrix, !1, t.projectionMatrix), 
            e.uniformMatrix4fv(this._skyProgram.uniforms.viewMatrix, !1, t.viewMatrix), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), 
            e.vertexAttribPointer(this._skyProgram.attributes.vertex, 3, e.FLOAT, !1, 0, 0), 
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.drawElements(e.TRIANGLES, this._numIndices, e.UNSIGNED_SHORT, 0), 
            e.disable(e.CULL_FACE);
        }
    };
    var Jt = function(t) {
        this.startLevel = t, this.level0NumTilesX = Math.pow(2, this.startLevel);
    };
    Jt.prototype = new L();
    var te = function(t) {
        return 20037508.34 * t / 180;
    }, ee = function(t) {
        var e = Math.log(Math.tan((90 + t) * Math.PI / 360)) / (Math.PI / 180);
        return 20037508.34 * e / 180;
    };
    Jt.prototype.generateLevelZeroTiles = function(t) {
        t.skirt = !0, t.cullSign = 1, t.srs = "EPSG:3857", t.project = function(t) {
            return [ te(t[0]), ee(t[1]) ];
        };
        for (var e = [], r = Math.pow(2, this.startLevel), i = Math.pow(2, this.startLevel), n = 0; n < i; n++) for (var o = 0; o < r; o++) {
            var s = new ne(this.startLevel, o, n);
            s.config = t, e.push(s);
        }
        return e;
    }, Jt.prototype._lon2LevelZeroIndex = function(t) {
        var e = (t + 180) / 360;
        return Math.min(this.level0NumTilesX - 1, Math.floor(e * this.level0NumTilesX));
    }, Jt.prototype._lat2LevelZeroIndex = function(t) {
        var e = Math.sin(t * Math.PI / 180), r = .5 - Math.log((1 + e) / (1 - e)) / (4 * Math.PI);
        return Math.min(this.level0NumTilesX - 1, Math.floor(r * this.level0NumTilesX));
    };
    var re = function(t, e) {
        return t / Math.pow(2, e) * 360 - 180;
    }, ie = function(t, e) {
        var r = Math.PI - 2 * Math.PI * t / Math.pow(2, e);
        return 180 / Math.PI * Math.atan(.5 * (Math.exp(r) - Math.exp(-r)));
    }, ne = function(t, e, r) {
        p.prototype.constructor.call(this), this.level = t, this.x = e, this.y = r, this.geoBound = new v(re(e, t), ie(r + 1, t), re(e + 1, t), ie(r, t)), 
        this.bound = new v(te(this.geoBound.west), ee(this.geoBound.south), te(this.geoBound.east), ee(this.geoBound.north));
    };
    ne.prototype = new p(), ne.prototype.getElevation = function(t, e) {
        return 0;
    }, ne.prototype.createChildren = function() {
        var t = new ne(this.level + 1, 2 * this.x, 2 * this.y), e = new ne(this.level + 1, 2 * this.x + 1, 2 * this.y), r = new ne(this.level + 1, 2 * this.x, 2 * this.y + 1), i = new ne(this.level + 1, 2 * this.x + 1, 2 * this.y + 1);
        t.initFromParent(this, 0, 0), e.initFromParent(this, 1, 0), r.initFromParent(this, 0, 1), 
        i.initFromParent(this, 1, 1), this.children = [ t, e, r, i ];
    }, ne.prototype.lonlat2tile = function(t) {
        for (var e = Math.pow(2, this.level), r = this.config.tesselation - 1, i = [], n = 0; n < t.length; n++) {
            var o = (t[n][0] + 180) / 360, s = Math.sin(t[n][1] * Math.PI / 180), a = .5 - Math.log((1 + s) / (1 - s)) / (4 * Math.PI);
            i.push([ r * (o * e - this.x), r * (a * e - this.y) ]);
        }
        return i;
    }, ne.prototype.generateVertices = function(t) {
        this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
        var e = h.create();
        h.inverse(this.matrix, e), this.inverseMatrix = e;
        for (var r = this.config.tesselation, i = new Float32Array(3 * r * (r + 6)), n = 1 / (r - 1), o = this.config.coordinateSystem.radius, s = this.config.coordinateSystem.heightScale, a = 0, l = Math.pow(2, this.level), u = this.y, c = 0; c < r; c++) {
            for (var d = Math.PI * (1 - 2 * u / l), f = Math.atan(.5 * (Math.exp(d) - Math.exp(-d))), p = Math.cos(f), m = Math.sin(f), v = this.x, g = 0; g < r; g++) {
                var y = Math.PI * (2 * v / l - 1), x = t ? s * t[a] : 0, b = (o + x) * Math.cos(y) * p, T = (o + x) * Math.sin(y) * p, _ = (o + x) * m, M = 3 * a;
                i[M] = e[0] * b + e[4] * T + e[8] * _ + e[12], i[M + 1] = e[1] * b + e[5] * T + e[9] * _ + e[13], 
                i[M + 2] = e[2] * b + e[6] * T + e[10] * _ + e[14], a++, v += n;
            }
            u += n;
        }
        return i;
    }, ne.prototype.buildSkirtVertices = function(t, e, r, i) {
        var n = this.config.tesselation, o = this.config.vertexSize, s = Math.pow(2, this.level), a = 0 == this.y && i == o * (n * n), l = this.y == s - 1 && i == o * ((n + 1) * n);
        if (a || l) {
            var u = this.vertices, c = this.config.coordinateSystem.fromGeoTo3D(a ? [ 0, 90, 0 ] : [ 0, -90, 0 ]);
            h.multiplyVec3(this.inverseMatrix, c);
            for (var d = 0; d < n; d++) {
                u[i] = c[0], u[i + 1] = c[1], u[i + 2] = c[2];
                for (var f = 3; f < o; f++) u[i + f] = u[e + f];
                i += o;
            }
        } else p.prototype.buildSkirtVertices.call(this, t, e, r, i);
    };
    var oe = function() {
        function t(t, e, r) {
            return Math.min(Math.max(t, e), r);
        }
        function e(t) {
            return 256 << t;
        }
        function r(r, i, h) {
            r = t(r, n, o), i = t(i, s, a);
            var l = (i + 180) / 360, u = Math.sin(r * Math.PI / 180), c = .5 - Math.log((1 + u) / (1 - u)) / (4 * Math.PI), d = e(h), f = t(l * d + .5, 0, d - 1), p = t(c * d + .5, 0, d - 1);
            return [ Math.floor(f), Math.floor(p) ];
        }
        function i(t, e, r) {
            for (var i = "", n = r; n > 0; n--) {
                var o = "0", s = 1 << n - 1;
                0 != (t & s) && o++, 0 != (e & s) && (o++, o++), i += o;
            }
            return i;
        }
        var n = -85.05112878, o = 85.05112878, s = -180, a = 180;
        return {
            tileXYToQuadKey: i,
            latLongToPixelXY: r
        };
    }(), se = function(t) {
        Ht.prototype.constructor.call(this, t), this.tilePixelSize = 256, this.tiling = new Jt(t.baseLevel || 2), 
        this.numberOfLevels = 18, this.baseUrl = "", this.baseUrlSubDomains = [], this._ready = !1;
        var e = this;
        window._bingTileProviderCallback = function(r) {
            e.baseUrl = r.resourceSets[0].resources[0].imageUrl, e.baseUrlSubDomains = r.resourceSets[0].resources[0].imageUrlSubdomains, 
            e._ready = !0, t.onready && t.onready instanceof Function && t.onready(e), e.globe && e.globe.renderContext.requestFrame();
        };
        var r = document.createElement("script");
        r.type = "text/javascript", r.src = "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" + t.imageSet + "?jsonp=_bingTileProviderCallback&key=" + t.key, 
        r.id = "_bingTileProviderCallback", document.getElementsByTagName("head")[0].appendChild(r);
    };
    m.inherits(Ht, se), se.prototype.getUrl = function(t) {
        var e = this.baseUrl.replace("{quadkey}", oe.tileXYToQuadKey(t.x, t.y, t.level));
        return e.replace("{subdomain}", this.baseUrlSubDomains[Math.floor(Math.random() * this.baseUrlSubDomains.length)]);
    };
    var ae = function(t) {
        this.renderContext = t.renderContext, this.tileManager = t;
        var e = "\tattribute vec3 vertex;\n\tattribute vec2 tcoord;\n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\tuniform vec4 extent; \n\t\tvarying vec2 texCoord;\n\t\tvoid main(void) \n\t{\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\t\ttexCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n\t\ttexCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n\t}\n\t", r = "\t#ifdef GL_ES\n\tprecision highp float;\n\t#endif\n\t\n\tvarying vec2 texCoord;\n\tuniform sampler2D overlayTexture;\n\tuniform mat3 transform;\n\tuniform float opacity; \n\t\n\tvoid main(void)\n\t{\n\t\tvec3 tc = transform * vec3(texCoord,1.0); \n\t\ttc.xy /= tc.z; \n\t\tgl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n\t\tgl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n\t}\n\t";
        this.program = new k(this.renderContext), this.program.createFromSource(e, r), this.groundOverlays = [];
    };
    ae.prototype.render = function(t) {
        var e = this.renderContext.gl;
        this.program.apply();
        var r = this.program.attributes;
        e.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, this.renderContext.projectionMatrix), 
        e.uniform1i(this.program.uniforms.overlayTexture, 0), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), 
        e.depthFunc(e.LEQUAL), e.depthMask(!1);
        for (var i = h.create(), n = null, o = 0; o < this.groundOverlays.length; o++) {
            var s = this.groundOverlays[o];
            if (s.image.complete) {
                s.texture || (s.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(s.image, s.flipY));
                for (var a = !1, l = 0; l < t.length; l++) {
                    var u = t[l];
                    if (s.geoBound.intersects(u.geoBound)) {
                        a || (e.uniformMatrix3fv(this.program.uniforms.transform, !1, s.inverseTransform), 
                        e.uniform1f(this.program.uniforms.opacity, s.opacity), e.activeTexture(e.TEXTURE0), 
                        e.bindTexture(e.TEXTURE_2D, s.texture), e.bindBuffer(e.ARRAY_BUFFER, this.tileManager.tcoordBuffer), 
                        e.vertexAttribPointer(r.tcoord, 2, e.FLOAT, !1, 0, 0), a = !0);
                        var c = u.state == p.State.LOADED ? u.bound : u.parent.bound;
                        e.uniform4f(this.program.uniforms.extent, c.west, c.east, c.north, c.south), h.multiply(this.renderContext.viewMatrix, u.matrix, i), 
                        e.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, i), e.bindBuffer(e.ARRAY_BUFFER, u.vertexBuffer), 
                        e.vertexAttribPointer(r.vertex, 3, e.FLOAT, !1, 0, 0);
                        var d = u.state == p.State.LOADED ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(u.parentIndex);
                        n != d && (e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, d), n = d), e.drawElements(e.TRIANGLES, d.numIndices, e.UNSIGNED_SHORT, 0);
                    }
                }
            }
        }
        e.disable(e.BLEND), e.depthMask(!0);
    };
    var he = function(t) {
        zt.prototype.constructor.call(this, t), this.quad = t.quad, this.opacity = t.opacity || 1, 
        void 0 === t.flipY ? this.flipY = !0 : this.flipY = t.flipY, this.geoBound = new v(), 
        this.geoBound.computeFromCoordinates(this.quad), "string" == typeof t.image ? (this.image = new Image(), 
        this.image.crossOrigin = "", this.image.src = t.image) : t.image instanceof HTMLImageElement && (this.image = t.image), 
        this.globe = null;
    };
    m.inherits(zt, he), he.prototype._attach = function(t) {
        var e = t.groundOverlayRenderer;
        e || (e = new ae(t.tileManager), t.tileManager.addPostRenderer(e), t.groundOverlayRenderer = e), 
        e.groundOverlays.push(this), this.globe = t, this.computeTransform();
    }, he.prototype._detach = function(t) {
        var e = this.globe.groundOverlayRenderer;
        if (e) {
            var r = e.groundOverlays.indexOf(this);
            r != -1 && (e.groundOverlays.splice(r, 1), 0 == e.groundOverlays.length && (this.globe.tileManager.removePostRenderer(e), 
            this.globe.groundOverlayRenderer = null));
        }
    }, he.prototype.computeInverse = function() {
        var t, e, r, i, n, o, s, a, h, l = this.transform[0] * (this.transform[8] * this.transform[4] - this.transform[5] * this.transform[7]) - this.transform[3] * (this.transform[8] * this.transform[1] - this.transform[7]) * this.transform[3] + this.transform[6] * (this.transform[5] * this.transform[1] - this.transform[4] * this.transform[2]);
        t = this.transform[4] * this.transform[8] - this.transform[5] * this.transform[7], 
        i = this.transform[5] * this.transform[6] - this.transform[3] * this.transform[8], 
        s = this.transform[3] * this.transform[7] - this.transform[4] * this.transform[6], 
        e = this.transform[2] * this.transform[7] - this.transform[1] * this.transform[8], 
        n = this.transform[0] * this.transform[8] - this.transform[2] * this.transform[6], 
        a = this.transform[1] * this.transform[6] - this.transform[0] * this.transform[7], 
        r = this.transform[1] * this.transform[5] - this.transform[2] * this.transform[4], 
        o = this.transform[2] * this.transform[3] - this.transform[0] * this.transform[5], 
        h = this.transform[0] * this.transform[4] - this.transform[1] * this.transform[3], 
        this.inverseTransform = [ t / l, e / l, r / l, i / l, n / l, o / l, s / l, a / l, h / l ];
    }, he.prototype.computeTransform = function() {
        var t = this.quad[0], e = this.quad[1], r = this.quad[2], i = this.quad[3], n = this.globe.tileManager.tileConfig;
        "EPSG:4326" != n.srs && (t = n.project(t), e = n.project(e), r = n.project(r), i = n.project(i));
        var o = t[0], s = e[0], a = r[0], h = i[0], l = t[1], u = e[1], c = r[1], d = i[1], f = o - s + a - h, p = l - u + c - d;
        if (f || p) {
            var m, v, g, y, x, b, T, _, M = s - a, R = h - a, S = u - c, w = d - c, P = f * w - R * p, E = M * p - f * S, C = M * w - R * S;
            if (!C) return;
            T = P / C, _ = E / C, m = s - o + T * s, v = h - o + _ * h, g = o, y = u - l + T * u, 
            x = d - l + _ * d, b = l, this.transform = [ m, y, T, v, x, _, g, b, 1 ];
        } else this.transform = [ s - o, u - l, 0, a - s, c - u, 0, o, l, 1 ];
        this.computeInverse();
    };
    var le = function(t) {
        Ht.prototype.constructor.call(this, t), this.tilePixelSize = t.tilePixelSize || 256, 
        this.tiling = new Jt(t.baseLevel || 2), this.numberOfLevels = t.numberOfLevels || 21, 
        this.baseUrl = t.baseUrl;
    };
    m.inherits(Ht, le), le.prototype.getUrl = function(t) {
        var e = this.baseUrl + "/" + t.level + "/" + t.x + "/" + t.y + ".png";
        return e;
    };
    var ue = function(t) {
        zt.prototype.constructor.call(this, t), this.outline = !(!t || !t.outline) && t.outline, 
        this.color = t && t.color ? t.color : [ 1, 1, 1 ], this.globe = null, this.program = null, 
        this.indexBuffer = null, this.subIndexBuffer = [ null, null, null, null ], this.zIndex = -1;
    };
    m.inherits(zt, ue), ue.prototype.buildIndexBuffer = function() {
        for (var t = this.globe.renderContext.gl, e = this.globe.tileManager.tileConfig.tesselation, r = [], i = this.outline ? e - 1 : 1, n = 0; n < e; n += i) for (var o = 0; o < e - 1; o++) r.push(n * e + o), 
        r.push(n * e + o + 1);
        for (var n = 0; n < e; n += i) for (var o = 0; o < e - 1; o++) r.push(o * e + n), 
        r.push((o + 1) * e + n);
        var s = t.createBuffer();
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array(r), t.STATIC_DRAW), 
        s.numIndices = r.length, this.indexBuffer = s;
        var a = (e - 1) / 2;
        i = this.outline ? a : 1;
        for (var h = 0; h < 4; h++) {
            for (var o = h % 2, n = Math.floor(h / 2), r = [], l = a * n; l < a * (n + 1) + 1; l += i) for (var u = a * o; u < a * (o + 1); u++) r.push(l * e + u), 
            r.push(l * e + u + 1);
            for (var l = a * o; l < a * (o + 1) + 1; l += i) for (var u = a * n; u < a * (n + 1); u++) r.push(u * e + l), 
            r.push((u + 1) * e + l);
            var s = t.createBuffer();
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array(r), t.STATIC_DRAW), 
            s.numIndices = r.length, this.subIndexBuffer[h] = s;
        }
    }, ue.prototype._attach = function(t) {
        if (zt.prototype._attach.call(this, t), this._visible && this.globe.tileManager.addPostRenderer(this), 
        !this.program) {
            var e = "\t\tattribute vec3 vertex;\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\t\tvoid main(void) \n\t\t{\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\t\t}\n\t\t", r = "\t\tprecision highp float; \n\t\tuniform vec3 color; \n\t\tuniform float alpha; \n\t\tvoid main(void)\n\t\t{\n\t\t\tgl_FragColor = vec4(color,alpha);\n\t\t}\n\t\t";
            this.program = new k(this.globe.renderContext), this.program.createFromSource(e, r), 
            this.buildIndexBuffer();
        }
    }, ue.prototype._detach = function() {
        this.globe.tileManager.removePostRenderer(this), zt.prototype._detach.call(this);
    }, ue.prototype.render = function(t) {
        var e = this.globe.renderContext, r = e.gl;
        r.enable(r.BLEND), this.program.apply(), r.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, e.projectionMatrix);
        for (var i = this.program.attributes.vertex, n = null, o = 0; o < t.length; o++) {
            var s = t[o], a = s.state == p.State.LOADED, l = s.parentIndex == -1;
            h.multiply(e.viewMatrix, s.matrix, e.modelViewMatrix), r.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, e.modelViewMatrix), 
            r.uniform3f(this.program.uniforms.color, this.color[0], this.color[1], this.color[2]), 
            r.uniform1f(this.program.uniforms.alpha, this.opacity()), r.bindBuffer(r.ARRAY_BUFFER, s.vertexBuffer), 
            r.vertexAttribPointer(i, 3, r.FLOAT, !1, 4 * s.config.vertexSize, 0);
            var u = a || l ? this.indexBuffer : this.subIndexBuffer[s.parentIndex];
            n != u && (r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, u), n = u);
            n.numIndices;
            r.drawElements(r.LINES, n.numIndices, r.UNSIGNED_SHORT, 0);
        }
        r.disable(r.BLEND);
    }, ue.prototype.visible = function(t) {
        return zt.prototype.visible.call(this, t), "boolean" == typeof t && (this._visible ? this.globe.tileManager.addPostRenderer(this) : this.globe.tileManager.removePostRenderer(this)), 
        this._visible;
    };
    var ce = function() {};
    ce.prototype.createWMS = function(t) {
        return layer = new jt(t), layer;
    }, ce.prototype.createWCSElevation = function(t) {
        return layer = new Qt(t), layer;
    }, ce.prototype.createVector = function() {
        return layer = new Kt(), layer;
    }, ce.prototype.createAtmosphere = function(t) {
        return layer = new $t(t), layer;
    }, ce.prototype.createWMTS = function(t) {
        return layer = new Zt(t), layer;
    }, ce.prototype.createBing = function() {
        return layer = new se(), layer;
    }, ce.prototype.createGroundOverlay = function(t) {
        return layer = new he(t), layer;
    }, ce.prototype.createOSM = function(t) {
        return layer = new le(t), layer;
    }, ce.prototype.createTileWireframe = function(t) {
        return layer = new ue(t), layer;
    }, ce.prototype.getCapabilities = function() {
        capabilities = [ {
            protocol: "WMS",
            method: "createWMS",
            parameters: [ {
                mandatory: "yes",
                name: "baseUrl",
                type: "String",
                desc: "URL of the WMS server"
            }, {
                mandatory: "yes",
                name: "layers",
                type: "String",
                desc: "List of Layers names, separated with comma"
            } ]
        }, {
            protocol: "WCS",
            method: "createWCSElevation",
            parameters: [ {
                mandatory: "yes",
                name: "baseUrl",
                type: "String",
                desc: "URL of the WCS server"
            }, {
                mandatory: "yes",
                name: "coverage",
                type: "String",
                desc: "Name of the layer"
            }, {
                mandatory: "no",
                name: "version",
                type: "String",
                desc: "Version of the protocol"
            } ]
        }, {
            protocol: "-",
            method: "createVector",
            parameters: []
        }, {
            protocol: "-",
            method: "createAtmosphere",
            parameters: [ {
                mandatory: "no",
                name: "kr",
                type: "Float",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "km",
                type: "Float",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "sunBrightness",
                type: "Float",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "exposure",
                type: "Float",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "wavelength",
                type: "ArrayOfFloat",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "lightDir",
                type: "Float",
                desc: "TODO"
            } ]
        }, {
            protocol: "WMTS",
            method: "createWMTS",
            parameters: [ {
                mandatory: "yes",
                name: "baseUrl",
                type: "String",
                desc: "URL of the WTMS server"
            }, {
                mandatory: "no",
                name: "tilePixelSize",
                type: "Integer",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "numberOfLevels",
                type: "Integer",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "startLevel",
                type: "Integer",
                desc: "TODO"
            } ]
        }, {
            protocol: "BING",
            method: "createBing",
            parameters: []
        }, {
            protocol: "-",
            method: "createGroundOverlay",
            parameters: [ {
                mandatory: "yes",
                name: "image",
                type: "String",
                desc: "URL of the image"
            } ]
        }, {
            protocol: "OSM",
            method: "createOSM",
            parameters: [ {
                mandatory: "yes",
                name: "baseUrl",
                type: "String",
                desc: "URL of the OSM server"
            }, {
                mandatory: "no",
                name: "tilePixelSize",
                type: "Integer",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "baseLevel",
                type: "Integer",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "numberOfLevels",
                type: "Integer",
                desc: "TODO"
            } ]
        }, {
            protocol: "-",
            method: "createTileWireframe",
            parameters: [ {
                mandatory: "no",
                name: "outline",
                type: "Boolean",
                desc: "TODO"
            }, {
                mandatory: "no",
                name: "color",
                type: "Color",
                desc: "TODO"
            } ]
        } ];
    };
    var de = function() {
        de.LayerFactory = new ce();
    };
    return de.prototype.createGlobe = function(t) {
        return de.MizarGlobe = new qt(t), de.MizarGlobe;
    }, de.prototype.createStats = function(t, e) {
        return de.Stats = new yt(t, e), de.Stats;
    }, de.prototype.createNavigation = function(t) {
        return de.Navigation = new ct(t), de.Navigation;
    }, de.prototype.getLayerFactory = function() {
        return de.LayerFactory;
    }, window.Mizar = de, require([ "Mizar" ]), de;
}();